{
    "version": "https://jsonfeed.org/version/1",
    "title": "lessone",
    "subtitle": "此去应多羡",
    "icon": "https://lessone.top/images/favicon.ico",
    "description": "This is lessone's blog",
    "home_page_url": "https://lessone.top",
    "items": [
        {
            "id": "https://lessone.top/Software-Security-Course-Design/",
            "url": "https://lessone.top/Software-Security-Course-Design/",
            "title": "Software Security Course Design",
            "date_published": "2024-03-21T02:33:38.000Z",
            "content_html": "<h1 id=\"项目说明\"><a class=\"anchor\" href=\"#项目说明\">#</a> 项目说明</h1>\n<p>对于无源码情况下分析样本程序的行为，有多种方法。其中，基于 API HOOK 的方法是本次软件安全课程设计的任务。</p>\n<p>APIGuard 是我们设计的一款轻量级的、基于 Detours 库开发的异常行为检测软件。它的前端采用<strong> MFC</strong> 开发，后端依赖<strong> Detours</strong> 库，完成 dll 注射以及 Win API 截获的功能。</p>\n<p>其具体功能如下：</p>\n<ul>\n<li>APIGuard 能够完成对大部分<strong>弹窗、堆操作、文件操作、注册表操作、socket 操作和线程进程</strong>操作完成截获，并将调用的参数告知使用者。</li>\n<li>APIGuard 能够选择是否<strong>提示</strong>弹窗、堆操作、文件操作、注册表操作和 socket 操作的截获。</li>\n<li>APIGuard 能够告知用户程序企图创建进程并运行的程序名，并<strong>让用户选择是否运行</strong>。</li>\n<li>APIGuard 能够在截获的基础上完成一些<strong>异常行为分析</strong>，如程序自我复制、堆二次释放和创建恶意进程等。</li>\n<li>一些基本的软件信息，包括版权所有（<s>也许没用</s>）、联系作者和开源仓库跳转等。</li>\n</ul>\n<h1 id=\"环境搭建\"><a class=\"anchor\" href=\"#环境搭建\">#</a> 环境搭建</h1>\n<p>你可以在<em>发行版</em>中直接下载最新版 APIGuard，也可以搭建环境参与 APIGuard 开发：</p>\n<p>一些基本的操作流程如下：</p>\n<ul>\n<li>下载安装 Visual Studio 2022；</li>\n<li>下载 Detours 4.0.1 源码，并完成编译；</li>\n<li>打开 OurWork/Dll1/Dll1.sln 和 OurWork / 注射器 /injector/injector.sln，选择 “<em>项目</em>”-“<em>属性</em>”-“<em>VC++ 目录</em>”，修改<em>包含目录</em>和<em>库目录</em>为你的 Detours 4.0.1 编译结果路径。</li>\n<li>参与开发，丰富功能。</li>\n</ul>\n<h1 id=\"使用说明\"><a class=\"anchor\" href=\"#使用说明\">#</a> 使用说明</h1>\n<p>我们<em><strong>强烈建议</strong></em>在<strong>使用时关闭搜狗拼音</strong>，它会造成程序截获到未知原因的 “HeapFree” 等行为。</p>\n<p><img data-src=\"image.png\" alt=\"主UI\" /></p>\n<ul>\n<li>选择 “<em>文件</em>” - “<em>打开</em>” 运行可疑程序并开始截获。（如果你暂时不知道该运行什么，我们在 OurWork/app/app 中给出了一个测试程序）</li>\n<li>程序会在<em> Functions 框</em>中输出截获到的函数</li>\n<li>单击<em> Functions 框</em>，程序会在<em> Details 框</em>中显示调用参数、调用时间等详细信息</li>\n<li>当截获到一些潜在的危险行为，程序会在<em> Warnings 框</em>中输出提示信息</li>\n<li>选择 “<em>帮助 (H)</em>” 查看版权信息、联系我们。</li>\n</ul>\n<h1 id=\"开源仓库\"><a class=\"anchor\" href=\"#开源仓库\">#</a> 开源仓库</h1>\n<p>项目的开源仓库链接：</p>\n<p><div class=\"links\"><div class=\"item\" title=\"lessone\" style=\"--block-color:#9d5b8b;\"><span class=\"exturl image\" data-url=\"aHR0cHM6Ly9naXRlZS5jb20vbGVzcy1vbmUvaHVzdC1kZXRvdXJz\" data-background-image=\"/images/avatar.jpg\"></span>\n          <div class=\"info\">\n          <span class=\"exturl title\" data-url=\"aHR0cHM6Ly9naXRlZS5jb20vbGVzcy1vbmUvaHVzdC1kZXRvdXJz\">APIGuard</span>\n          <p class=\"desc\">APIGuard开源仓库</p>\n          </div></div></div></p>\n",
            "tags": [
                "HUST本科学习",
                "HUST",
                "API HOOK",
                "课程设计",
                "异常行为检测"
            ]
        },
        {
            "id": "https://lessone.top/GameSecurityFinalWork/",
            "url": "https://lessone.top/GameSecurityFinalWork/",
            "title": "GameSecurityFinal",
            "date_published": "2024-02-21T07:17:54.000Z",
            "content_html": "<h1 id=\"shooterclient游戏分析\"><a class=\"anchor\" href=\"#shooterclient游戏分析\">#</a> ShooterClient 游戏分析</h1>\n<h2 id=\"查看游戏引擎\"><a class=\"anchor\" href=\"#查看游戏引擎\">#</a> 查看游戏引擎</h2>\n<ul>\n<li>ShooterClient 游戏分析部分的 UWorld、Gname 和 GObject 分析参考了：<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuNTJwb2ppZS5jbi90aHJlYWQtMTY5NjgxNi0xLTEuaHRtbA==\">https://www.52pojie.cn/thread-1696816-1-1.html</span></li>\n</ul>\n<p>右键查看 ShooterClient.exe 属性，点击详细信息。<br />\n<img data-src=\"image.png\" alt=\"ShooterClient.exe属性详细信息截图\" /></p>\n<p>可以得知 ShooterClient 是由 Epic Games 的 Unreal Engine 4.22.2.0 开发的。</p>\n<h2 id=\"uworld分析\"><a class=\"anchor\" href=\"#uworld分析\">#</a> UWorld 分析</h2>\n<ul>\n<li>\n<p>分析查找 UWorld，用 x64dbg 附加到游戏，右键 “搜索”—“所有模块”—“字符串”。</p>\n</li>\n<li>\n<p>按下 “Ctrl+F”，搜索字符串<strong> SeamlessTravel FlushLevelStreaming</strong>。<br />\n<img data-src=\"image-1.png\" alt=\"查找字符串结果图\" /></p>\n</li>\n<li>\n<p>双击跳转到该地址，向上翻，找到语句‘btr edx,0x7’，再向上翻找到第一个基地址，即语句 'mov qword ptr ds:[7FF76DFC1060]' 中的地址即为 UWorld。<br />\n<img data-src=\"image-2.png\" alt=\"UWorld分析结果图\" /></p>\n</li>\n<li>\n<p>分析可知，UWorld 的地址为：<br />\n<strong>UWorld = ShooterClient.exe + 0x2F71060</strong></p>\n</li>\n</ul>\n<h2 id=\"gname分析\"><a class=\"anchor\" href=\"#gname分析\">#</a> Gname 分析</h2>\n<p>下面开始分析 GName。</p>\n<ul>\n<li>\n<p>将 Cheat Engine 附加到游戏，搜索字符串<strong> ByteProperty</strong>。<br />\n<img data-src=\"image-3.png\" alt=\"查找字符串结果图\" /></p>\n</li>\n<li>\n<p>依次选择每个地址，查看附近内存，选择附近内存包含 “None”“IntProperty” 等字符串的地址，最终锁定为地址‘1F32E080024’。<br />\n<img data-src=\"image-4.png\" alt=\"ByteProperty附近内存截图\" /></p>\n</li>\n<li>\n<p>分析字符串之间的间隔，选择该片内存地址的第一个地址，即 1F32E080000，在 CE 中搜索这个地址。<br />\n<img data-src=\"image-5.png\" alt=\"搜索地址1F32E080000结果图\" /></p>\n</li>\n<li>\n<p>继续选择地址 1F32E040000 作为新的扫描值，搜索地址。<br />\n<img data-src=\"image-6.png\" alt=\"搜索地址1F32E040000结果图\" /></p>\n</li>\n<li>\n<p>继续选择地址 1F32E030080 作为新的扫描值，搜索地址。<br />\n<img data-src=\"image-7.png\" alt=\"GName分析结果图\" /></p>\n</li>\n<li>\n<p>此时得到两个偏移地址，先暂存，后续代码验证发现 “ShooterClient.exe+2E6E0C0” 为 GName 偏移结果。故 GName 地址为：<strong>GName = ShooterClient.exe + 2E6E0C0</strong></p>\n</li>\n</ul>\n<h2 id=\"gobject分析\"><a class=\"anchor\" href=\"#gobject分析\">#</a> GObject 分析</h2>\n<p>下面开始分析 Gobject。</p>\n<ul>\n<li>\n<p>用 x64dbg 附加到游戏，搜索字符串 “CanvasObject”。<br />\n<img data-src=\"image-8.png\" alt=\"字符串搜索结果图\" /></p>\n</li>\n<li>\n<p>双击跳转到该地址，向上翻，找到语句‘sar eax,10’。这一条下面的基地址就是 GObject。<br />\n<img data-src=\"image-9.png\" alt=\"GObject分析结果图\" /></p>\n</li>\n</ul>\n<p>故 GObject 结果为：<strong>GObject = ShooterClient.exe + 2B8CA70</strong></p>\n<h2 id=\"分析实现\"><a class=\"anchor\" href=\"#分析实现\">#</a> 分析实现</h2>\n<h3 id=\"sdk-dump\"><a class=\"anchor\" href=\"#sdk-dump\">#</a> sdk dump</h3>\n<p>采用工具：UnrealEngineSDKGenerator 进行 dump 生成 sdk。工具如图所示。<br />\n<img data-src=\"image-10.png\" alt=\"dump工具截图\" /></p>\n<ul>\n<li>在游戏配置文件中修改 Gnames、GObjects 等参数后进行生成。<br />\n<img data-src=\"image-11.png\" alt=\"工具dump部分结果截图\" /></li>\n</ul>\n<h3 id=\"代码验证\"><a class=\"anchor\" href=\"#代码验证\">#</a> 代码验证</h3>\n<p><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;windows.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;thread&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cstdint&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;tlhelp32.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> GameProcessName <span class=\"string\">&quot;ShooterClient.exe&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Memory</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    std::string processName;</span><br><span class=\"line\">    HANDLE processHandle;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Memory</span>() : <span class=\"built_in\">processHandle</span>(<span class=\"literal\">NULL</span>) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">SetProcessName</span><span class=\"params\">(<span class=\"type\">const</span> std::string&amp; name)</span> </span>&#123;</span><br><span class=\"line\">    \tprocessName = name;</span><br><span class=\"line\"></span><br><span class=\"line\">    \tHANDLE hSnapshot = <span class=\"built_in\">CreateToolhelp32Snapshot</span>(TH32CS_SNAPPROCESS, <span class=\"number\">0</span>);</span><br><span class=\"line\">    \t<span class=\"keyword\">if</span> (hSnapshot) &#123;</span><br><span class=\"line\">    \t    PROCESSENTRY32 pe32;</span><br><span class=\"line\">    \t    pe32.dwSize = <span class=\"built_in\">sizeof</span>(PROCESSENTRY32);</span><br><span class=\"line\">\t</span><br><span class=\"line\">    \t    <span class=\"keyword\">if</span> (<span class=\"built_in\">Process32First</span>(hSnapshot, &amp;pe32)) &#123;</span><br><span class=\"line\">    \t        <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">    \t            <span class=\"keyword\">if</span> (<span class=\"built_in\">strcmp</span>(pe32.szExeFile, processName.<span class=\"built_in\">c_str</span>()) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    \t                processHandle = <span class=\"built_in\">OpenProcess</span>(PROCESS_ALL_ACCESS, FALSE, pe32.th32ProcessID);</span><br><span class=\"line\">    \t                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    \t            &#125;</span><br><span class=\"line\">    \t        &#125; <span class=\"keyword\">while</span> (<span class=\"built_in\">Process32Next</span>(hSnapshot, &amp;pe32));</span><br><span class=\"line\">    \t    &#125;</span><br><span class=\"line\">    \t    <span class=\"built_in\">CloseHandle</span>(hSnapshot);</span><br><span class=\"line\">    \t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span></span><br><span class=\"line\"><span class=\"function\">    T <span class=\"title\">Read</span><span class=\"params\">(<span class=\"type\">uint64_t</span> address)</span> </span>&#123;</span><br><span class=\"line\">    \tT value;</span><br><span class=\"line\">    \t<span class=\"keyword\">if</span> (processHandle) &#123;</span><br><span class=\"line\">    \t    SIZE_T bytesRead;</span><br><span class=\"line\">    \t    <span class=\"built_in\">ReadProcessMemory</span>(processHandle, (LPCVOID)address, &amp;value, <span class=\"built_in\">sizeof</span>(T), &amp;bytesRead);</span><br><span class=\"line\">    \t&#125;</span><br><span class=\"line\">    \t<span class=\"keyword\">return</span> value;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">uint64_t</span> <span class=\"title\">GetProcessBaseAddress</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    \t<span class=\"type\">uint64_t</span> baseAddress = <span class=\"number\">0</span>;</span><br><span class=\"line\">    \tHANDLE hSnapshot = <span class=\"built_in\">CreateToolhelp32Snapshot</span>(TH32CS_SNAPMODULE | TH32CS_SNAPMODULE32, <span class=\"built_in\">GetProcessId</span>(processHandle));</span><br><span class=\"line\"></span><br><span class=\"line\">    \t<span class=\"keyword\">if</span> (hSnapshot != INVALID_HANDLE_VALUE) &#123;</span><br><span class=\"line\">    \t    MODULEENTRY32 moduleEntry;</span><br><span class=\"line\">    \t    moduleEntry.dwSize = <span class=\"built_in\">sizeof</span>(MODULEENTRY32);</span><br><span class=\"line\"></span><br><span class=\"line\">    \t    <span class=\"keyword\">if</span> (<span class=\"built_in\">Module32First</span>(hSnapshot, &amp;moduleEntry)) &#123;</span><br><span class=\"line\">    \t        <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">    \t            <span class=\"keyword\">if</span> (<span class=\"built_in\">strcmp</span>(moduleEntry.szModule, processName.<span class=\"built_in\">c_str</span>()) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    \t                baseAddress = (<span class=\"type\">uint64_t</span>)moduleEntry.modBaseAddr;</span><br><span class=\"line\">    \t                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    \t            &#125;</span><br><span class=\"line\">    \t        &#125; <span class=\"keyword\">while</span> (<span class=\"built_in\">Module32Next</span>(hSnapshot, &amp;moduleEntry));</span><br><span class=\"line\">    \t    &#125;</span><br><span class=\"line\">    \t    <span class=\"built_in\">CloseHandle</span>(hSnapshot);</span><br><span class=\"line\">    \t&#125;</span><br><span class=\"line\">    \t<span class=\"keyword\">return</span> baseAddress;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">ReadBuffer</span><span class=\"params\">(<span class=\"type\">uint64_t</span> address, <span class=\"type\">void</span>* buffer, SIZE_T bufferSize)</span> </span>&#123;</span><br><span class=\"line\">\t    <span class=\"keyword\">if</span> (processHandle &amp;&amp; buffer != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">    \t    SIZE_T bytesRead;</span><br><span class=\"line\">    \t    <span class=\"keyword\">return</span> <span class=\"built_in\">ReadProcessMemory</span>(processHandle, (LPCVOID)address, buffer, bufferSize, &amp;bytesRead) != <span class=\"number\">0</span>;</span><br><span class=\"line\">    \t&#125;</span><br><span class=\"line\">    \t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t</span><br><span class=\"line\">    ~<span class=\"built_in\">Memory</span>() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (processHandle) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">CloseHandle</span>(processHandle);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Memory* pMemory;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">GlobalAddress</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">static</span> <span class=\"type\">uint64_t</span> BaseAddress;</span><br><span class=\"line\">    <span class=\"type\">static</span> <span class=\"type\">uint64_t</span> GNames;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">uint64_t</span> GlobalAddress::BaseAddress;</span><br><span class=\"line\"><span class=\"type\">uint64_t</span> GlobalAddress::GNames;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">ShooterClient_Loop</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">std::string <span class=\"title\">GetNameFormId_</span><span class=\"params\">(<span class=\"type\">uint32_t</span> Id)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> ChunkIndex = Id / <span class=\"number\">0x4000</span>;</span><br><span class=\"line\">\t<span class=\"type\">int</span> WithinChunkIndex = Id % <span class=\"number\">0x4000</span>;</span><br><span class=\"line\">\t<span class=\"type\">uint64_t</span> NamePtr = pMemory-&gt;<span class=\"built_in\">Read</span>&lt;<span class=\"type\">uint64_t</span>&gt;(GlobalAddress::GNames + <span class=\"number\">0x8</span> * ChunkIndex);</span><br><span class=\"line\">\t<span class=\"type\">uint64_t</span> FName = pMemory-&gt;<span class=\"built_in\">Read</span>&lt;<span class=\"type\">uint64_t</span>&gt;(NamePtr + <span class=\"number\">0x8</span> * WithinChunkIndex);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tCHAR name[<span class=\"number\">256</span>];</span><br><span class=\"line\">\tpMemory-&gt;<span class=\"built_in\">ReadBuffer</span>(FName+<span class=\"number\">0xc</span>,name,<span class=\"built_in\">sizeof</span>(name));</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> std::<span class=\"built_in\">string</span>(name);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">ShooterClient_Loop</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">uint64_t</span> UWorld = pMemory-&gt;<span class=\"built_in\">Read</span>&lt;<span class=\"type\">uint64_t</span>&gt;(GlobalAddress::BaseAddress + <span class=\"number\">0x2F71060</span>);</span><br><span class=\"line\">\t<span class=\"type\">uint64_t</span> ULeval = pMemory-&gt;<span class=\"built_in\">Read</span>&lt;<span class=\"type\">uint64_t</span>&gt;(UWorld + <span class=\"number\">0x30</span>);</span><br><span class=\"line\">\t<span class=\"type\">uint64_t</span> Actor = pMemory-&gt;<span class=\"built_in\">Read</span>&lt;<span class=\"type\">uint64_t</span>&gt;(ULeval + <span class=\"number\">0x98</span>);</span><br><span class=\"line\">\t<span class=\"type\">uint32_t</span> Actor_Count = pMemory-&gt;<span class=\"built_in\">Read</span>&lt;<span class=\"type\">uint32_t</span>&gt;(ULeval + <span class=\"number\">0x98</span> + <span class=\"number\">0x8</span>);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;Actor_Count;++i)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">uint64_t</span> pObject = pMemory-&gt;<span class=\"built_in\">Read</span>&lt;<span class=\"type\">uint64_t</span>&gt;(Actor + i * <span class=\"number\">0x8</span>);</span><br><span class=\"line\">\t\t<span class=\"type\">uint32_t</span> ObjectId = pMemory-&gt;<span class=\"built_in\">Read</span>&lt;<span class=\"type\">uint32_t</span>&gt;(pObject + <span class=\"number\">0x18</span>);</span><br><span class=\"line\"><span class=\"comment\">//\t\tstd::cout&lt;&lt;&quot;pObject: &quot;&lt;&lt;pObject&lt;&lt;&#x27;\\n&#x27;;</span></span><br><span class=\"line\">\t\tstd::string ObjectName = <span class=\"built_in\">GetNameFormId_</span>(ObjectId);</span><br><span class=\"line\"><span class=\"comment\">//\t\tstd::cout&lt;&lt;&quot;ObjectName: &quot;&lt;&lt;ObjectName&lt;&lt;&#x27;\\n&#x27;;</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!ObjectName.<span class=\"built_in\">compare</span>(<span class=\"string\">&quot;BotPawn_C&quot;</span>)) &#123;</span><br><span class=\"line\">    \t\t<span class=\"type\">uint64_t</span> botPositionAddress;</span><br><span class=\"line\">    \t\tFLOAT bot[<span class=\"number\">3</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    \t\t<span class=\"keyword\">if</span> (pMemory-&gt;<span class=\"built_in\">ReadBuffer</span>((<span class=\"type\">uint64_t</span>)pObject + <span class=\"number\">0x3A0</span>, &amp;botPositionAddress, <span class=\"built_in\">sizeof</span>(botPositionAddress))) &#123;</span><br><span class=\"line\">        \t\t<span class=\"keyword\">if</span> (pMemory-&gt;<span class=\"built_in\">ReadBuffer</span>(botPositionAddress + <span class=\"number\">0x1A0</span>, bot, <span class=\"built_in\">sizeof</span>(bot))) &#123;</span><br><span class=\"line\">            \t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;bot location: [x:%f, y:%f, z:%f]\\n&quot;</span>, bot[<span class=\"number\">0</span>], bot[<span class=\"number\">1</span>], bot[<span class=\"number\">2</span>]);</span><br><span class=\"line\">        \t\t&#125;</span><br><span class=\"line\">    \t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tpMemory = <span class=\"keyword\">new</span> Memory;</span><br><span class=\"line\">\tpMemory-&gt;<span class=\"built_in\">SetProcessName</span>(GameProcessName);</span><br><span class=\"line\">\tGlobalAddress::BaseAddress = pMemory-&gt;<span class=\"built_in\">GetProcessBaseAddress</span>();</span><br><span class=\"line\">\tGlobalAddress::GNames = pMemory-&gt;<span class=\"built_in\">Read</span>&lt;<span class=\"type\">uint64_t</span>&gt;(GlobalAddress::BaseAddress + <span class=\"number\">0x2e6e0c0</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(<span class=\"literal\">true</span>)&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">ShooterClient_Loop</span>();</span><br><span class=\"line\">\t\t<span class=\"built_in\">Sleep</span>(<span class=\"number\">1000</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>ShooterClient_Loop () 遍历游戏对象的列表，检查它们的名称是否与 &quot;BotPawn_C&quot; 匹配，如果是，则提取并打印它们的位置。</li>\n<li>Memory 类负责处理与内存相关的操作。其中：\n<ul>\n<li>SetProcessName 函数设置进程名称，并尝试使用 Windows ToolHelp 函数打开对指定进程的句柄；</li>\n<li>Read 函数从指定地址的进程内存中读取指定类型的值；</li>\n<li>GetProcessBaseAddress 函数通过列举模块来检索进程的基址；</li>\n<li>ReadBuffer 函数从进程内存中读取数据缓冲区。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"实现结果\"><a class=\"anchor\" href=\"#实现结果\">#</a> 实现结果</h3>\n<ul>\n<li>\n<p>首先打印所有 Object。<br />\n<img data-src=\"image-12.png\" alt=\"编写程序打印Object结果图\" /></p>\n</li>\n<li>\n<p>尝试每隔 1 秒打印机器人位置坐标。</p>\n</li>\n</ul>\n<p><div id=\"dplayer0\" class=\"dplayer hexo-tag-dplayer-mark\" style=\"margin-bottom: 20px;\"></div><script>(function(){var player = new DPlayer({\"container\":document.getElementById(\"dplayer0\"),\"video\":{\"url\":\"/cheat.mkv\"},\"danmaku\":{\"id\":\"someid\",\"api\":\"https://api.prprpr.me/dplayer/\",\"addition\":[\"/some.json\"]}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);player.on(\"loadstart\",function(){console.log(\"loadstart\")})})()</script></p>\n<h1 id=\"hack分析\"><a class=\"anchor\" href=\"#hack分析\">#</a> hack 分析</h1>\n<h2 id=\"detect-it-easy查壳\"><a class=\"anchor\" href=\"#detect-it-easy查壳\">#</a> Detect it easy 查壳</h2>\n<ul>\n<li>用 Detect It Easy 查看 hack.exe 文件加壳情况。如图 1 所示。<br />\n<img data-src=\"image-13.png\" alt=\"查壳\" /></li>\n<li>可知，hack.exe 通过 VMProtect 加壳。</li>\n</ul>\n<h2 id=\"导入函数分析\"><a class=\"anchor\" href=\"#导入函数分析\">#</a> 导入函数分析</h2>\n<ul>\n<li>用 ida64 查看 imports 导入函数，分析可能对调试有帮助的函数。<br />\n<img data-src=\"image-14.png\" alt=\"Ida部分导入函数截图\" /></li>\n<li>可以看到，导入函数中包括了：\n<ul>\n<li>反调试：\n<ul>\n<li>IsDebuggerPresent\t 检测是否在调试器下运行</li>\n</ul>\n</li>\n<li>进程和线程操作：\n<ul>\n<li>GetCurrentProcess, GetCurrentProcessId: 获取当前进程及其 ID。</li>\n<li>CreateToolhelp32Snapshot, Process32First, Process32Next: 进程遍历函数。</li>\n<li>OpenProcess, TerminateProcess: 打开或终止进程。</li>\n<li>CreateEventW, SetEvent, WaitForSingleObject: 事件操作函数。</li>\n<li>GetThreadLocale, GetUserDefaultLCID, GetSystemDefaultLCID: 处理地区和语言信息。</li>\n</ul>\n</li>\n<li>内存和堆操作：\n<ul>\n<li>GlobalAlloc, GlobalFree, GlobalLock, GlobalUnlock: 全局内存操作函数。</li>\n<li>HeapAlloc, HeapFree: 堆内存操作函数。</li>\n<li>LocalAlloc, LocalFree: 本地内存操作函数。</li>\n</ul>\n</li>\n<li>鼠标操作：\n<ul>\n<li>SetCursorPos, GetCursorPos, SetCapture, ReleaseCapture: 鼠标操作。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>通过导入函数，猜测 hack.exe 主要通过：</p>\n<ul>\n<li>使用 CreateToolhelp32Snapshot、Process32First 和 Process32Next 等函数<em>遍历系统进程，找到游戏进程</em>；</li>\n<li>使用 ReadProcessMemory 函数<em>读取游戏进程的内存，包括机器人的位置信息</em>；</li>\n<li>使用 GetAsyncKeyState <em>获取按键状态，判断是否按下鼠标右键</em>；</li>\n<li>如果获取鼠标按下右键，则调用 SetCursorPos <em>设置鼠标位置，用于自动瞄准</em>。</li>\n</ul>\n<h2 id=\"x64dbg调试查找oep\"><a class=\"anchor\" href=\"#x64dbg调试查找oep\">#</a> x64dbg 调试查找 OEP</h2>\n<h3 id=\"方法一\"><a class=\"anchor\" href=\"#方法一\">#</a> 方法一</h3>\n<ul>\n<li>使用 x64dbg 调试 hack.exe，使用 ScyllaHide 插件绕过反调试，将 Loaded 选项设置为 VMProtect x86/x64。</li>\n<li><img data-src=\"image-15.png\" alt=\"ScyllaHide插件绕过反调试设置\" /></li>\n</ul>\n<ol>\n<li>一次‘运行’后，hack.exe 来到 Entrypoint，紧接着三次‘运行’，hack.exe 在三次‘nop’指令后正常运行。<br />\n<img data-src=\"image-16.png\" alt=\"三次nop后正常运行\" /></li>\n<li>从 Entrypoint 处重新开始调试，一直单步步过，直到语句‘pushfq’，如所示。<br />\n<img data-src=\"image-17.png\" alt=\"步过到pushfq语句\" /></li>\n<li>发现只有 RSP 寄存器发生变化，符合 ESP 脱壳定律，右键点击 RSP，选择 “在内存窗口中转到”，对此时的 RSP 值 “14FF00” 下硬件访问断点。<br />\n<img data-src=\"image-18.png\" alt=\"对栈顶下断点截图\" /></li>\n<li>一直 F9，经过三次 nop 和多次无关指令后停留在下图所示处。<br />\n<img data-src=\"image-19.png\" alt=\"多次F9后停留位置\" /></li>\n<li>发现此时 RSP（14FF08）接近 pushfq 时的（14FF00），且在当前代码上方找到 popfq。</li>\n<li>继续单步步入，程序 jmp 到图 8 所示位置，观察这部分代码：<br />\n<strong>sub rsp 28” + call + “add rsp 28，为 Visual Studio 程序的常见脱壳入口点，故得到 OEP，即 140052188。</strong><br />\n<img data-src=\"image-20.png\" alt=\"方法一程序OEP位置截图\" /><br />\n常见脱壳入口点：<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC85NmE2ZGQ2YTBjZTUlRTMlODAlODI=\">https://www.jianshu.com/p/96a6dd6a0ce5。</span><br />\n<img data-src=\"image-21.png\" alt=\"脱壳入口特征\" /></li>\n</ol>\n<h3 id=\"方法二\"><a class=\"anchor\" href=\"#方法二\">#</a> 方法二</h3>\n<ol>\n<li>\n<p>根据 2.2 导入函数分析的结果，选择‘CreateToolhelp32Snapshot’作为断点进行调试最合适。在 x64dbg 中按下‘Ctrl + G’，输入‘CreateToolhelp32Snapshot’，转到地址，设置断点，结果如下图所示。<br />\n<img data-src=\"image-22.png\" alt=\"为‘CreateToolhelp32Snapshot’创建断点\" /></p>\n</li>\n<li>\n<p>继续调试，发现程序会两次停留在‘CreateToolhelp32Snapshot’处的断点，其中第二次断下时，RAX 的值为 “ShooterClient.exe”，故猜测此次为查找游戏进程。<br />\n<img data-src=\"image-24.png\" alt=\"根据第二次断下时RAX的值判断为查找游戏进程\" /></p>\n</li>\n<li>\n<p>查看此时的调用堆栈，如下图所示。<br />\n<img data-src=\"image-25.png\" alt=\"第二次断下时的堆栈调用截图\" /></p>\n</li>\n<li>\n<p>根据此时的断点位置（kernel32.00007FF88C856AF0），锁定在 33956 线程，如图 13 所示。<br />\n<img data-src=\"image-26.png\" alt=\"33956线程堆栈调用截图\" /></p>\n</li>\n<li>\n<p>从下往上查找第一个以 hack 为基地址的地址，锁定在 hack.0000000140052118，双击跳转到该地址。<br />\n<img data-src=\"image-27.png\" alt=\"主程序进调用的地址截图\" /></p>\n</li>\n<li>\n<p>向上找到程序入口，找到该片段的第一条指令，地址为 14005200C，如下图所示。<br />\n<img data-src=\"image-28.png\" alt=\"该片段第一条指令截图\" /></p>\n</li>\n<li>\n<p>单击右键，查找引用 — 选中的地址。<br />\n<img data-src=\"image-29.png\" alt=\"查找引用截图\" /><br />\n<img data-src=\"image-30.png\" alt=\"查找引用结果截图\" /></p>\n</li>\n<li>\n<p>找到地址，双击进入查看，同样能找到 OEP。<br />\n<img data-src=\"image-31.png\" alt=\"方法二查找OEP结果截图\" /></p>\n</li>\n</ol>\n<h2 id=\"脱壳\"><a class=\"anchor\" href=\"#脱壳\">#</a> 脱壳</h2>\n<ul>\n<li>使用 x64dbg 自带的 scylla 插件 dump 脱壳。点击‘dump’，再点击 IAT Autosearch，最后点击 Get Imports，结果如下图所示。<br />\n<img data-src=\"image-32.png\" alt=\"Scylla dump截图\" /></li>\n<li>点击‘Fix Dump’，得到脱壳后的程序 hack_dump_SCY.exe。</li>\n<li>使用 DIE 查看脱壳结果，如下图所示。<br />\n<img data-src=\"image-33.png\" alt=\"DIE查看hack_dump_SCY.exe\" /></li>\n<li>说明脱壳成功，打开 hack_dump_SCY.exe，文件能正常运行。</li>\n</ul>\n<p><img data-src=\"image-34.png\" alt=\"hack_dump_SCY.exe正常运行截图\" /></p>\n<h2 id=\"ida分析脱壳后的文件\"><a class=\"anchor\" href=\"#ida分析脱壳后的文件\">#</a> IDA 分析脱壳后的文件</h2>\n<h3 id=\"main函数分析\"><a class=\"anchor\" href=\"#main函数分析\">#</a> main 函数分析</h3>\n<ol>\n<li>\n<p>用 IDA 打开脱壳后的 hack_dump_SCY.exe，“Ctrl + F” 查找 main 函数，分析 main 函数逻辑。<br />\n<img data-src=\"image-35.png\" alt=\"hack_dump_SCY.exe main函数\" /></p>\n</li>\n<li>\n<p>依次分析 main 中的主要代码，主要函数逻辑用注释标出。<br />\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> __cdecl <span class=\"title\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">const</span> <span class=\"type\">char</span> **argv, <span class=\"type\">const</span> <span class=\"type\">char</span> **envp)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"type\">char</span> *v3; <span class=\"comment\">// rax</span></span><br><span class=\"line\">  __int64 v4; <span class=\"comment\">// rax</span></span><br><span class=\"line\">  <span class=\"type\">char</span> *v5; <span class=\"comment\">// rax</span></span><br><span class=\"line\">  <span class=\"type\">char</span> *v6; <span class=\"comment\">// rax</span></span><br><span class=\"line\">  <span class=\"type\">char</span> *v7; <span class=\"comment\">// rax</span></span><br><span class=\"line\">  __int64 v8; <span class=\"comment\">// rax</span></span><br><span class=\"line\">  <span class=\"type\">void</span> *v9; <span class=\"comment\">// rax</span></span><br><span class=\"line\">  __int64 v10; <span class=\"comment\">// rax</span></span><br><span class=\"line\">  <span class=\"type\">char</span> v12; <span class=\"comment\">// [rsp+21h] [rbp-C7h] BYREF</span></span><br><span class=\"line\">  <span class=\"type\">char</span> v13; <span class=\"comment\">// [rsp+22h] [rbp-C6h] BYREF</span></span><br><span class=\"line\">  <span class=\"type\">char</span> v14; <span class=\"comment\">// [rsp+23h] [rbp-C5h] BYREF</span></span><br><span class=\"line\">  <span class=\"type\">char</span> v15; <span class=\"comment\">// [rsp+24h] [rbp-C4h] BYREF</span></span><br><span class=\"line\">  <span class=\"type\">char</span> v16[<span class=\"number\">3</span>]; <span class=\"comment\">// [rsp+25h] [rbp-C3h] BYREF</span></span><br><span class=\"line\">  <span class=\"type\">void</span> *v17; <span class=\"comment\">// [rsp+28h] [rbp-C0h]</span></span><br><span class=\"line\">  __int64 v18; <span class=\"comment\">// [rsp+30h] [rbp-B8h]</span></span><br><span class=\"line\">  LPCSTR lpWindowName; <span class=\"comment\">// [rsp+38h] [rbp-B0h]</span></span><br><span class=\"line\">  LPCSTR lpClassName; <span class=\"comment\">// [rsp+40h] [rbp-A8h]</span></span><br><span class=\"line\">  HWND hWnd; <span class=\"comment\">// [rsp+48h] [rbp-A0h]</span></span><br><span class=\"line\">  __int64 v22; <span class=\"comment\">// [rsp+50h] [rbp-98h]</span></span><br><span class=\"line\">  <span class=\"type\">char</span> *v23; <span class=\"comment\">// [rsp+58h] [rbp-90h]</span></span><br><span class=\"line\">  __int64 v24; <span class=\"comment\">// [rsp+60h] [rbp-88h]</span></span><br><span class=\"line\">  __int64 v25; <span class=\"comment\">// [rsp+68h] [rbp-80h]</span></span><br><span class=\"line\">  <span class=\"type\">char</span> v26[<span class=\"number\">11</span>]; <span class=\"comment\">// [rsp+70h] [rbp-78h] BYREF</span></span><br><span class=\"line\">  <span class=\"type\">char</span> v27[<span class=\"number\">13</span>]; <span class=\"comment\">// [rsp+7Bh] [rbp-6Dh] BYREF</span></span><br><span class=\"line\">  <span class=\"type\">char</span> v28[<span class=\"number\">14</span>]; <span class=\"comment\">// [rsp+88h] [rbp-60h] BYREF</span></span><br><span class=\"line\">  <span class=\"type\">char</span> v29[<span class=\"number\">18</span>]; <span class=\"comment\">// [rsp+96h] [rbp-52h] BYREF</span></span><br><span class=\"line\">  <span class=\"type\">char</span> v30[<span class=\"number\">24</span>]; <span class=\"comment\">// [rsp+A8h] [rbp-40h] BYREF</span></span><br><span class=\"line\">  <span class=\"type\">char</span> v31; <span class=\"comment\">// [rsp+C0h] [rbp-28h] BYREF</span></span><br><span class=\"line\"></span><br><span class=\"line\">  v3 = <span class=\"built_in\">sub_1400036B0</span>((__int64)&amp;v12, v29);       <span class=\"comment\">// 读取th32ProcessID解混淆前的数据</span></span><br><span class=\"line\">  v4 = <span class=\"built_in\">sub_140003920</span>((__int64)v3);              <span class=\"comment\">// 解混淆得到&quot;ShooterClient.exe&quot;</span></span><br><span class=\"line\">  th32ProcessID = <span class=\"built_in\">sub_140001920</span>(v4);            <span class=\"comment\">// 获取游戏进程的 ID</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( (<span class=\"type\">unsigned</span> __int8)<span class=\"built_in\">sub_1400019C0</span>(th32ProcessID) )<span class=\"comment\">// 检查游戏进程是否存在</span></span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    v5 = <span class=\"built_in\">sub_1400037F0</span>((__int64)&amp;v13, v28);     <span class=\"comment\">// 读取lpWindowName解混淆前的数据</span></span><br><span class=\"line\">    lpWindowName = (LPCSTR)<span class=\"built_in\">sub_1400038E0</span>((__int64)v5);<span class=\"comment\">// 解混淆得到&quot;ShooterGame&quot;</span></span><br><span class=\"line\">    v6 = <span class=\"built_in\">sub_140003750</span>((__int64)&amp;v14, v27);     <span class=\"comment\">// 读取lpClassName解混淆前的数据</span></span><br><span class=\"line\">    lpClassName = (LPCSTR)<span class=\"built_in\">sub_140003900</span>((__int64)v6);<span class=\"comment\">// 解混淆得到&quot;UnrealWindow&quot;</span></span><br><span class=\"line\">    hWnd = <span class=\"built_in\">FindWindowA</span>(lpClassName, lpWindowName);<span class=\"comment\">// 根据窗口类名和窗口标题查找游戏窗口的句柄</span></span><br><span class=\"line\">    <span class=\"built_in\">GetClientRect</span>(hWnd, &amp;Rect);                 <span class=\"comment\">// 获取游戏窗口的坐标</span></span><br><span class=\"line\">    v7 = <span class=\"built_in\">sub_1400036B0</span>((__int64)&amp;v15, v30);     <span class=\"comment\">// 读取数据</span></span><br><span class=\"line\">    v8 = <span class=\"built_in\">sub_140003920</span>((__int64)v7);            <span class=\"comment\">// 解混淆得到&quot;ShooterClient.exe&quot;</span></span><br><span class=\"line\">    qword_1400C12E0 = (__int64)<span class=\"built_in\">sub_140001AA0</span>(v8);<span class=\"comment\">// 遍历进程，找到游戏模块的基址</span></span><br><span class=\"line\">    v17 = <span class=\"built_in\">sub_140051874</span>(<span class=\"number\">0xC0</span>ui64);              <span class=\"comment\">// 申请一块内存</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( v17 )                                  <span class=\"comment\">// 申请内存成功</span></span><br><span class=\"line\">      v18 = <span class=\"built_in\">sub_14004C570</span>((__int64)v17);        <span class=\"comment\">// 初始化内存</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">      v18 = <span class=\"number\">0</span>i64;</span><br><span class=\"line\">    v22 = v18;</span><br><span class=\"line\">    qword_1400C12A8 = v18;                      <span class=\"comment\">// 将初始化的内存地址保存到全局变量中</span></span><br><span class=\"line\">    *(_DWORD *)(v18 + <span class=\"number\">16</span>) = Rect.right - Rect.left;<span class=\"comment\">// 将窗口的宽度保存到内存中</span></span><br><span class=\"line\">    *(_DWORD *)(qword_1400C12A8 + <span class=\"number\">20</span>) = Rect.bottom - Rect.top;<span class=\"comment\">// 将窗口的高度保存到内存中</span></span><br><span class=\"line\">    v23 = &amp;v31;</span><br><span class=\"line\">    v9 = <span class=\"built_in\">sub_140003890</span>((__int64)v16, v26);      <span class=\"comment\">// 读取混淆前数据</span></span><br><span class=\"line\">    v10 = <span class=\"built_in\">sub_1400038C0</span>((__int64)v9);           <span class=\"comment\">// 解混淆得到&quot;simhei.ttf&quot;(一种字体)</span></span><br><span class=\"line\">    v24 = <span class=\"built_in\">sub_140003B10</span>((__int64)v23, v10);     <span class=\"comment\">// 设置字体为simhei.ttf</span></span><br><span class=\"line\">    v25 = v24;</span><br><span class=\"line\">    <span class=\"built_in\">sub_14004CD10</span>(qword_1400C12A8, v24, (__int64)sub_140003460);<span class=\"comment\">// 根据初始化的内存，以simhei.ttf为字体，创建一个窗口，实现作弊逻辑</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">sub_1400581EC</span>();</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n</li>\n</ol>\n<h3 id=\"读取数据解混淆\"><a class=\"anchor\" href=\"#读取数据解混淆\">#</a> 读取数据解混淆</h3>\n<ul>\n<li>Hack.exe 对 th32ProcessID、lpWindowName 和 lpClassName 都做了混淆处理。且混淆方法相同，下面以 th32ProcessID 为例进行解混淆。</li>\n</ul>\n<h3 id=\"sub_1400036b0函数\"><a class=\"anchor\" href=\"#sub_1400036b0函数\">#</a> sub_1400036B0 函数</h3>\n<ul>\n<li>sub_1400036B0 函数用于读取混淆后的数据，sub_140003920 函数用于解混淆。<br />\n<img data-src=\"image-36.png\" alt=\"sub_1400036B0函数读取数据\" /></li>\n<li>查看 aKquthxl0kI 的值，如下图所示。<br />\n<img data-src=\"image-37.png\" alt=\"aKquthxl0kI的值\" /></li>\n</ul>\n<h3 id=\"sub_140003920函数\"><a class=\"anchor\" href=\"#sub_140003920函数\">#</a> sub_140003920 函数</h3>\n<p><img data-src=\"image-38.png\" alt=\"sub_140003920函数调用sub_140003C40函数\" /><br />\n<img data-src=\"image-39.png\" alt=\"sub_140003C40函数调用sub_140003640函数\" /><br />\n<img data-src=\"image-40.png\" alt=\"sub_140003640函数截图\" /></p>\n<ul>\n<li>sub_140003640 函数中包含解混淆关键代码。</li>\n<li>结合 sub_1400036B0 函数读取的数据，编写代码验证结果，结果如下图所示。<br />\n<img data-src=\"image-41.png\" alt=\"th32ProcessID解混淆结果截图\" /></li>\n<li>分析可知，程序加密了读取的游戏进程名称，并在程序开始时通过解混淆得到该名称，加大了分析难度。</li>\n<li>其他解混淆结果如下图所示。<br />\n<img data-src=\"image-42.png\" alt=\"其他解混淆结果截图\" /></li>\n</ul>\n<h3 id=\"作弊逻辑实现\"><a class=\"anchor\" href=\"#作弊逻辑实现\">#</a> 作弊逻辑实现</h3>\n<ul>\n<li>根据 main 函数分析，不难得出，程序解混淆、找到游戏进程、获取偏移后会开始实现主要作弊逻辑。并且，根据对 hack.exe 的使用，作弊会在弹窗、根据用户选择作弊功能后开始进行。因此，依次查看弹窗后的调用的函数，寻找作弊代码，最终锁定在 sub_140003460 () 函数。<br />\n<img data-src=\"image-43.png\" alt=\"作弊函数\" /></li>\n<li>分别查看 sub_140001B50 () 和 sub_140003430 () 的代码。</li>\n</ul>\n<h3 id=\"sub_140001b50函数\"><a class=\"anchor\" href=\"#sub_140001b50函数\">#</a> sub_140001B50 () 函数</h3>\n<p><img data-src=\"image-44.png\" alt=\"sub_140001B50()函数代码截图\" /></p>\n<ul>\n<li>第 21 行程序调用 GetAsyncKeyState 函数，查看键码表可知，36 对应的是 HOME 键，打开 hack.exe，可以发现，HOME 键可以切换菜单的开关，故猜测该部分代码是实现菜单窗口逻辑。</li>\n<li>依次分析 if 中的函数，其主要逻辑和之前分析的解混淆相似，有两个取解混淆后的数据的函数，猜测是为了生成 UI。</li>\n</ul>\n<h3 id=\"sub_140003430函数\"><a class=\"anchor\" href=\"#sub_140003430函数\">#</a> sub_140003430 () 函数</h3>\n<p><img data-src=\"image-45.png\" alt=\"sub_140003430()函数代码截图\" /></p>\n<ul>\n<li>依次查看这几个函数，在 sub_140002D70 () 中找到熟悉的代码片段。<br />\n<img data-src=\"image-46.png\" alt=\"sub_140002D70()函数部分代码截图\" /></li>\n<li>55 行至 57 行的代码与 1.5.2 代码验证中的遍历对象代码形式相同，且偏移量 8*i 也相同，引起注意。仔细分析，可以发现该部分主要用于遍历所有的 Object 读取 name，与解混淆后的字符串比对，判断是否为机器人，若是机器人，则跳转执行后续操作。</li>\n<li>通过第 97 行 sub_140004350 () 中的 ReadProcessMemory 函数读取机器人坐标。</li>\n<li>外挂通过调用 ReadProcessMemory 函数，遍历所有 Actor 对象并过滤得到机器人的地址，再通过偏移得到各数据信息。</li>\n<li>再通过对将世界坐标系到视图坐标系的转换，将机器人坐标显示在屏幕上。<br />\n<img data-src=\"image-48.png\" alt=\"自瞄部分代码\" /></li>\n<li>第 136 行检查鼠标右键状态，并在第 145 行再次读取坐标，说明该部分代码主要实现自瞄逻辑。读取到机器人坐标，映射在屏幕上，再转换玩家视角，实现自瞄功能。</li>\n</ul>\n",
            "tags": [
                "HUST本科学习",
                "HUST",
                "游戏设计与安全",
                "shooterclient",
                "期末作业"
            ]
        },
        {
            "id": "https://lessone.top/SoftwareSecurity/",
            "url": "https://lessone.top/SoftwareSecurity/",
            "title": "SoftwareSecurity",
            "date_published": "2024-01-29T02:28:03.000Z",
            "content_html": "<h1 id=\"第一章\"><a class=\"anchor\" href=\"#第一章\">#</a> 第一章</h1>\n<p>网络空间的两个子空间：代码子空间、数据子空间</p>\n<h2 id=\"为什么软件测试无法保证软件的安全性\"><a class=\"anchor\" href=\"#为什么软件测试无法保证软件的安全性\">#</a> 为什么软件测试无法保证软件的安全性？</h2>\n<ol>\n<li>\n<p>由于软件系统规模越来越大，软件开发的进度要求越来越高，不可能在有限的时间内考虑所有安全方面的问题，即使进行了全方位的测试，也只能对所有的测试案例进行很小范围的覆盖。</p>\n</li>\n<li>\n<p>关于测试，另一个问题是，全面的测试，一般情况下是针对所有可能出现的隐患进行测试，但是这需要对软件的隐患具有全方位的预见性。而在有些情况下，很多隐患是在运行期间才显露出来的，软件的开发者很难在开发阶段预见到所有可能出现的隐患，容易让测试陷入盲目。</p>\n</li>\n</ol>\n<h2 id=\"存在问题的代码案例\"><a class=\"anchor\" href=\"#存在问题的代码案例\">#</a> 存在问题的代码案例</h2>\n<h2 id=\"软件缺陷和错误\"><a class=\"anchor\" href=\"#软件缺陷和错误\">#</a> 软件缺陷和错误</h2>\n<ul>\n<li>\n<p>错误是指软件实现过程出现的问题，大多数的错误可以很容易发现并修复，缓冲区溢出、死锁、不安全的系统调用、不完整的输入检测机制和不完善的数据保护措施等；</p>\n</li>\n<li>\n<p>缺陷是一个更深层次的问题，它往往产生于设计阶段并在代码中实例化且难于发现，如设计期间的功能划分问题等，这种问题带来的危害更大，但是不属于编程的范畴。</p>\n</li>\n</ul>\n<h2 id=\"软件安全问题产生的基本原因从软件工程客观角度\"><a class=\"anchor\" href=\"#软件安全问题产生的基本原因从软件工程客观角度\">#</a> 软件安全问题产生的基本原因（从软件工程客观角度）</h2>\n<p>从软件工程客观角度讲，软件的安全性隐患又来源于以下几个方面：</p>\n<ol>\n<li>\n<p>软件复杂性和工程进度的平衡（为什么软件测试无法保证软件的安全性 1）；</p>\n</li>\n<li>\n<p>安全问题的不可预见性（为什么软件测试无法保证软件的安全性 2）；</p>\n</li>\n<li>\n<p>由于软件需求的变动；</p>\n</li>\n<li>\n<p>软件组件之间的交互的不可预见性。</p>\n</li>\n</ol>\n<h2 id=\"软件安全防护手段理解基本原理\"><a class=\"anchor\" href=\"#软件安全防护手段理解基本原理\">#</a> 软件安全防护手段（理解基本原理）</h2>\n<ul>\n<li>安全设计与开发：在软件开发阶段尽量减少软件缺陷和漏洞的数量。微软：SDL 开发模式</li>\n<li>保障运行环境：软件完整性校验 &amp;&amp; 系统完整性校验（代表：可信计算）</li>\n<li>加强软件自身行为认证：向着预期的方式运行。信任链传递（静态可信 -&gt; 动态可信）</li>\n<li>恶意软件检测与查杀：反病毒软件</li>\n<li>黑客攻击防护：防火墙、入侵检测系统 IDS、入侵防护系统 IPS</li>\n<li>系统还原</li>\n<li>虚拟隔离：虚拟机、沙箱</li>\n</ul>\n<h1 id=\"第二章\"><a class=\"anchor\" href=\"#第二章\">#</a> 第二章</h1>\n<p>操作系统引导过程：BIOS→硬盘主引导（MBR）→活动分区主引导（DBR）→（操作系统引导程序）NTLDR/bootmgr→系统内核加载……</p>\n<p>恶意软件可以在哪些阶段重新获取控制权：系统引导、操作系统启动、应用程序执行。</p>\n<h2 id=\"程序在内存中的映像即程序地址空间分布\"><a class=\"anchor\" href=\"#程序在内存中的映像即程序地址空间分布\">#</a> 程序在内存中的映像，即程序地址空间分布</h2>\n<p><img data-src=\"image.png\" alt=\"Alt text\" /></p>\n<p><img data-src=\"image-1.png\" alt=\"Alt text\" /></p>\n<h2 id=\"两个进程的可执行程序映像加载地址都是00400000h但同一地址对应的的代码却不一样为什么\"><a class=\"anchor\" href=\"#两个进程的可执行程序映像加载地址都是00400000h但同一地址对应的的代码却不一样为什么\">#</a> 两个进程的可执行程序映像加载地址都是 00400000H，但同一地址对应的的代码却不一样，为什么？</h2>\n<p>虚拟地址经过不同的页表转换到不同的物理地址</p>\n<h2 id=\"有关malloc的三个思考题\"><a class=\"anchor\" href=\"#有关malloc的三个思考题\">#</a> 有关 malloc 的三个思考题</h2>\n<ol>\n<li>\n<p>windows 编程中 malloc 实际上能够支持多大的内存呢？</p>\n<p>Windows 下 32 位程序如果单纯看地址空间能有 4G 左右的内存可用，不过实际上系统会把其中 2G 的地址留给内核使用，所以你的程序最大能用 2G 的内存。 除去其他开销，你能用 malloc 申请到的内存只有 1.9G 左右。</p>\n</li>\n<li>\n<p>不断增加物理内存，能够增加 malloc 的内存大小吗？</p>\n<p>不断增加物理内存，并不能增加 malloc 的内存大小。</p>\n<p>首先需要明确的是：malloc 所申请到的内存大小并不是实际物理内存，而是虚拟内存。为什么 malloc 申请的是虚拟内存，不是物理内存呢？ 第一，由用户直接申请物理内存的方法提供给了用户直接访问物理地址的权力，而这样直接访问物理内存的方式过于危险；第二，只有物理内存才能运行和处理数据，但物理内存大小有限，如果将一个进程直接加载进物理内存太浪费空间。基于这两个原因，产生了使用虚拟内存的方法，让用户只能访问虚拟内存地址（如 malloc 申请内存），而由系统调配虚拟内存中的信息到物理内存中；避免了直接访问物理内存也避免了物理内存空间的浪费。</p>\n<p>其次，虚拟内存又是什么呢？ 物理内存指的就是我们电脑上的内存条，那虚拟内存既然不同于物理内存，且具有存储、读写数据的功能，那么很自然的我们就想到，虚拟内存的实际载体应该就是我们硬盘中没有被使用的部分。</p>\n<p>那么，虚拟内存又有多大呢？ 看到这里你可能认为，那既然虚拟内存的实际载体是硬盘，那它的大小应该和硬盘大小一样。但其实并不是这样的。为保证程序的组织、访问和载入的有序性，虚拟内存的大小被限定在一定范围内。对现有 32 位系统而言，虚拟内存的大小被设定为 2^32Byte=4GB。由此可见，虚拟内存的大小其实是由系统位数所决定的，和物理内存大小没有直接关系。</p>\n<p>这时我们便会思考，虚拟内存又是如何与物理内存联系的呢？ 实际上，系统为每个进程都分配了一个独立的 4GB 大小的虚拟内存空间。而这 4GB 大小的空间管理起来是很麻烦的，也不能直接把这些空间的内容加载进物理内存，因此，操作系统会自动对这个虚拟内存空间进行分页管理，将 4GB 划分成很多小页，并通过一个函数计算出当前虚拟内存地址在加载到物理内存时应该放在哪个物理地址，这些函数形成的表便是页表，通过这个页表就能将虚拟内存和物理内存联系起来。</p>\n<p>实际上，每个进程中只有很少一部分页加载并运行在物理内存上，绝大部分都处于虚拟内存中，正在等待被加载或者不需要被加载。当物理内存中的页被运行完成后，便通过页表信息将需要的页从虚拟内存加载进入物理内存进行运行。这样便完成了虚拟内存到物理内存的过程。</p>\n<p>综上可以得知，malloc 所能占用的大小就是一个进程的虚拟大小，而该大小由系统位数决定，和物理内存大小并没有实际关系。</p>\n</li>\n<li>\n<p>为什么增加物理内存，能够使得系统跑得更流畅呢？</p>\n<p>根据上面的理论，一部分进程在物理内存中运行完后，将进行下一部分的加载和运行，而增加物理内存后，可以使得加载的速度更快，等待的进程更少，从而使系统运行得更流畅。</p>\n<p>举个例子：假如物理内存跑 10 个就满了，不能再加了，那得等其中一个跑完再加载，这时候可能有 3 个还在等；但是扩大物理内存后，一个页还是那么大，所以同时能跑的个数就增加了，比如现在可能最多能跑 20 个，那系统原来运行了 13 个，有 3 个在等，而现在可以直接全跑上，不用等了，所以就快了。</p>\n</li>\n</ol>\n<h2 id=\"簇-fat\"><a class=\"anchor\" href=\"#簇-fat\">#</a> 簇 &amp;&amp; FAT</h2>\n<p>FAT 表是用于磁盘数据 (文件) 索引和定位引进的一种单向链式结构，表示簇的占用情况，表项的个数 = 簇的个数。</p>\n<p>簇大小 = 扇区大小（512B） * 2^n，簇是进行文件空间分配的最小单位。簇太大→浪费空间；簇太小→产生磁盘碎片。</p>\n<p>簇链：一个文件所占用的簇的序号形成的单向链表</p>\n<h2 id=\"为什么一般删除的文件可以恢复如何彻底删除文件\"><a class=\"anchor\" href=\"#为什么一般删除的文件可以恢复如何彻底删除文件\">#</a> 为什么一般删除的文件可以恢复 / 如何彻底删除文件？</h2>\n<p><img data-src=\"image-2.png\" alt=\"Alt text\" /></p>\n<p>清空回收站执行的操作就是删除该文件在 FAT 表中的记录。也就是说你执行彻底删除也就是删除并清空回收站后或者直接 shift+delete 删除，系统完成的操作就是在 FAT 表中标记这个文件已被移除，然后把红框框从磁盘上拿掉了，你的文件本质上还是存在的。</p>\n<p>删除文件并不是真正的 &quot;删除&quot; 文件，而是将被删除文件占用的磁盘位置标记为 &quot;可用空间&quot;，被删除文件只是被隐藏起来了。 当有新的文件要使用磁盘中这个位置时，系统就会直接覆盖原来的 &quot;被删除文件&quot;，这时才是真正意义上让文件消失。 这也是为什么删除文件的速度比复制文件的速度快的原因。 所以，如果执行删除操作后，文件的位置没有被覆盖，就能够轻松恢复，与删除时间无关。</p>\n<h2 id=\"peelf-具体文件格式及常用节头部\"><a class=\"anchor\" href=\"#peelf-具体文件格式及常用节头部\">#</a> PE/ELF 具体文件格式及常用节头部</h2>\n<p>常见的 exe、dll、ocx、sys、com 都是 PE 文件。</p>\n<p><img data-src=\"image-3.png\" alt=\"Alt text\" /></p>\n<p><img data-src=\"image-4.png\" alt=\"Alt text\" /></p>\n<h2 id=\"pe-文件与内存之间的映射\"><a class=\"anchor\" href=\"#pe-文件与内存之间的映射\">#</a> PE 文件与内存之间的映射</h2>\n<ul>\n<li>\n<p>文件偏移地址 FO/RA/Roffset：PE 文件在硬盘上存放时相对于文件头的偏移。</p>\n</li>\n<li>\n<p>装载地址 IB/Image Base：PE 装入内存时的基地址</p>\n</li>\n<li>\n<p>虚拟内存地址 VA：PE 文件中的指令被装入内存后的地址</p>\n</li>\n<li>\n<p>相对虚拟地址 RVA：指令的虚拟内存地址相对于装载基址的偏移量</p>\n</li>\n<li>\n<p>VA = Image Base + RVA</p>\n</li>\n<li>\n<p>磁盘：0x200 字节，内存 0x1000 字节。</p>\n</li>\n<li>\n<p>节偏移：由于磁盘和内存存储分配单位的差异引起的节基址之差；节偏移 = Voffset (该节在内存中的偏移量) - Roffset (该节在文件中的偏移量)</p>\n</li>\n<li>\n<p>文件偏移地址 FOA = VA − Image Base − VSO (虚拟内存节偏移)+FSO (文件节偏移) = RVA − VSO (虚拟内存节偏移 ) + FSO (文件节偏移)</p>\n</li>\n</ul>\n<p><img data-src=\"image-5.png\" alt=\"Alt text\" /></p>\n<h1 id=\"第三章\"><a class=\"anchor\" href=\"#第三章\">#</a> 第三章</h1>\n<p>恶意代码：设计目的是用来实现恶意功能的代码或程序。</p>\n<h2 id=\"恶意代码攻击目标\"><a class=\"anchor\" href=\"#恶意代码攻击目标\">#</a> 恶意代码攻击目标</h2>\n<ul>\n<li>\n<p>定点攻击：邮件、IP、域名、QQ、服务器列表、特定人员名单等</p>\n</li>\n<li>\n<p>群体性攻击：挂马攻击（在目标服务器或网站中植入恶意程序）、钓鱼攻击、病毒蠕虫自动扩散</p>\n</li>\n</ul>\n<p>注意：定点攻击和群体攻击的区分不是通过攻击的个体数量来区分，而是通过被攻击的个体是否能够被提前确定来区分。群体攻击中，无论是会传播的病毒木马还是钓鱼攻击，黑客在病毒、木马等被制作出来时不知道被攻击的对象是谁。</p>\n<h2 id=\"恶意代码功能静态-动态\"><a class=\"anchor\" href=\"#恶意代码功能静态-动态\">#</a> 恶意代码功能（静态、动态）</h2>\n<p>恶意代码功能：</p>\n<ol>\n<li>获取数据：静态数据（文件、数据库等）、动态数据（口令、内存、计算机网络流量、通信网络数据、可移动存储介质、隔离电脑等）</li>\n</ol>\n<p>静态数据和动态数据的区别：静态数据是指在运行过程中主要作为控制或参考用的数据，它们在很长的一段时间内不会变化，一般不随运行而变。动态数据包括所有在运行中发生变化的数据以及在运行中需要输入、输出的数据及在联机操作中要改变的数据。（来源：百度百科）</p>\n<ol start=\"2\">\n<li>\n<p>动态控制与渗透扩展攻击路径：中间系统、相关人员</p>\n</li>\n<li>\n<p>破坏系统：数据、系统服务、支撑设备</p>\n</li>\n</ol>\n<h2 id=\"计算机病毒与蠕虫定义\"><a class=\"anchor\" href=\"#计算机病毒与蠕虫定义\">#</a> 计算机病毒与蠕虫定义</h2>\n<ul>\n<li>\n<p>典型例子</p>\n<ul>\n<li>\n<p>病毒：熊猫烧香、CIH</p>\n</li>\n<li>\n<p>蠕虫：1988 年 Morris 莫里斯蠕虫、SQL 蠕虫王、震网、飞客、Stuxnet、flame；</p>\n</li>\n</ul>\n</li>\n<li>\n<p>各自特点及差异</p>\n<ul>\n<li>\n<p>病毒：病毒是通过感染计算机文件进行传播，以破坏或篡改用户数据，影响信息系统正常运行为主要目的恶意程序；是一段代码，能把自身加到程序其他程序包括操作系统上；它不能独立运行，需要由它的宿主运行来激活它</p>\n</li>\n<li>\n<p>蠕虫：蠕虫是指能自我复制和广泛传播，以占用系统和网络资源为主要目的的恶意序；可以独立运行，并能把自身的一个包含所有功能的版本传播到另外的计算机上。</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"木马与后门定义\"><a class=\"anchor\" href=\"#木马与后门定义\">#</a> 木马与后门定义</h2>\n<ul>\n<li>木马：是指一类看起来具有正常功能，但实际上隐藏着很多用户不希望功能的程序。通常由控制端和被控制端两端组成。</li>\n</ul>\n<p>典型例子：上兴、冰河、网络神偷、灰鸽子</p>\n<ul>\n<li>后门：使得攻击者可以对系统进行非授权访问的一类程序。</li>\n</ul>\n<p>典型例子：sunburst 后门</p>\n<h2 id=\"刑法285-286修正案七的司法解释情节严重的情形\"><a class=\"anchor\" href=\"#刑法285-286修正案七的司法解释情节严重的情形\">#</a> 刑法 285、286 修正案（七）的司法解释（情节严重的情形）</h2>\n<p>第二百八十五条 违反国家规定，侵入国家事务、国防建设、尖端科学技术领域的计算机信息系统的，处三年以下有期徒刑或者拘役……</p>\n<p>具有下列情形之一的，应当认为刑法 <strong>第二百八十五条</strong> 第二款规定的 &quot;情节严重&quot;：</p>\n<p>（一）获取支付结算、证券交易、期货交易等网络金融服务的身份认证信息 <strong>十组</strong> 以上的；</p>\n<p>（二）获取第（一）项以外的身份认证信息 <strong>五百组</strong> 以上的；</p>\n<p>（三）非法控制计算机信息系统 <strong>二十台</strong> 以上的；</p>\n<p>（四）违法所得 <strong>五千元</strong> 以上或者造成经济损失 <strong>一万元</strong> 以上的；</p>\n<p>（五）其他情节严重的情形。</p>\n<p>实施前款规定行为，具有下列情形之一的，应当认定为刑法第二百八十五条第二款规定的 &quot;情节特别严重&quot;：</p>\n<p>（一）数量或者数额达到前款第（一）项至第（四）项规定标准 <strong>五倍以上</strong> 的；</p>\n<p>（二）其他情节特别严重的情形。</p>\n<p>情节严重：三年以下有期徒刑或者拘役，并处或者单处罚金；</p>\n<p>情节特别严重：三年以上七年以下有期徒刑，并处罚金</p>\n<p>第二百八十六条 违反国家规定，对计算机信息系统功能进行删除、修改、增加、干扰，造成计算机信息系统不能正常运行，后果严重的，处五年以下有期徒刑或者拘役；后果特别严重的，处五年以上有期徒刑……</p>\n<h1 id=\"第四章\"><a class=\"anchor\" href=\"#第四章\">#</a> 第四章</h1>\n<p>根据导出函数表定位函数内存地址的方法：</p>\n<ol>\n<li>\n<p>从 AddressOfNames 中获取到需要定位的函数的名字（记下函数名的索引）</p>\n</li>\n<li>\n<p>从 AddressOfNameOrdinals 中获取到该函数的编号（以索引定位）</p>\n</li>\n<li>\n<p>从 AddressOfFunctions 中获取该编号对应函数的地址（编号值就是数组索引值）</p>\n</li>\n</ol>\n<p>exe 文件本身也属于文件，要想找到一个 exe 文件的某个导入函数的内存地址，首先应该在 exe 文件中找到可选头中存放的_______________，通过这个来定位到_________的地址，在这里可以通过遍历所有结构的________________字段来获取到这个函数的索引，接着在_____________________中找到这个索引下的地址值，即为目标函数在内存中的地址。</p>\n<p>IDT 的 RVA；IDT；OriginalFirstThunk；IAT</p>\n<h1 id=\"第五章\"><a class=\"anchor\" href=\"#第五章\">#</a> 第五章</h1>\n<p>感染：在尽量不影响目标程序（系统）正常功能的前提下，使其具有病毒自己的功能。</p>\n<p>感染目标类型：文件感染、系统感染；</p>\n<h2 id=\"关键技术重定位-api函数获取-目标检索-感染\"><a class=\"anchor\" href=\"#关键技术重定位-api函数获取-目标检索-感染\">#</a> 关键技术（重定位、API 函数获取、目标检索、感染）</h2>\n<h4 id=\"1-重定位病毒代码目标寄生位置不固定\"><a class=\"anchor\" href=\"#1-重定位病毒代码目标寄生位置不固定\">#</a> (1) 重定位：病毒代码目标寄生位置不固定</h4>\n<p><strong>原因解释</strong> ：在编译时，有些基于 Image Base 的指令会将地址固定写死在指令之中，如 push 0x401215，这时修改 Image Base 会使得这条指令的意义丢失，因此需要重定位。在病毒代码编译后而没有植入时，其起始地址很可能不是我们想要病毒代码在 HOST 文件中的起始地址，需要进行移动。</p>\n<p><strong>本质</strong> ：其本质是修正实际地址与预期地址的差异</p>\n<p><strong>解决方案</strong> ：</p>\n<ol>\n<li>\n<p>逐一硬编码（较为繁琐）</p>\n</li>\n<li>\n<p>病毒代码运行过程中自我重定位</p>\n</li>\n</ol>\n<p>call 指令可以将下一条要执行的指令的地址压入栈，配合 pop 即可得到下一条指令的地址，以此病毒就可以知道自己的地址是什么。</p>\n<h4 id=\"2-api函数自获取需要使用api函数但无引入函数节支撑\"><a class=\"anchor\" href=\"#2-api函数自获取需要使用api函数但无引入函数节支撑\">#</a> (2) API 函数自获取：需要使用 API 函数，但无引入函数节支撑</h4>\n<p><strong>解决方法：</strong></p>\n<ol>\n<li>首先获得 kernel32 模块中的任何一个地址；</li>\n<li>然后按照模块首地址特征（对齐于 10000H，PE 文件开始标志 MZ），向低地址遍历定位 PE 文件头，得到 kernel32.dll 的模块加载基地址；</li>\n<li>然后通过 kernel32.dll 的引出目录表结构定位具体函数的函数地址。</li>\n</ol>\n<p><strong>实现 1 的方法：</strong></p>\n<p><strong>a.</strong>  <strong>利用程序的返回地址（程序入口代码执行时，</strong> stack <strong>顶端存储的地址）</strong></p>\n<p>原理：系统打开一个可执行文件时，它会调用 Kernel32.dll 中的 CreateProcess 函数，CreateProcess 函数在完成应用程序装载后，会先将返回地址压入到堆栈顶端。当该应用程序结束后，会将返回地址弹出放到 EIP 中，继续执行。</p>\n<p>而这个返回地址正处于 KERNEL32.DLL 的地址空间之中。这样，利用 PE 文件格式的相关特征（如 03C 偏移处内容存放着 &quot;PE&quot; 标志的内存地址等），在此地址的基础上往低地址方向逐渐搜索，必然可以找到 KERNEL32.DLL 模块的首地址。不过这种暴力搜索方法比较费时，并且可能会碰到一些异常情况。</p>\n<p><strong>b.</strong> <strong>通过</strong> SEH<strong> 链获得 KERNEL32 模块内地址</strong></p>\n<p>原理：遍历 SEH 链，在链中查找 prev 成员等于 0xFFFFFFFF 的 EXCEPTION_REGISTER 结构，该结构中 handler 值指向系统异常处理例程，它总是位于 KERNEL32 模块中。根据这一特性，然后进行向前搜索就可以查找 KERNEL32.DLL 在内存中的基地址。</p>\n<p><strong>c.</strong>  <strong>通过</strong> PEB <strong>相关数据结构获取</strong></p>\n<ul>\n<li>\n<p>fs:[0] 指向 TEB 结构，首先从 fs:[30h] 获得 PEB 地址，</p>\n</li>\n<li>\n<p>然后通过 PEB [0x0c] 获得 PEB_LDR_DATA 数据结构地址，</p>\n</li>\n<li>\n<p>然后通过从 PEB_LDR_DATA [0x1c] 获取 InInitializationOrderModuleList.Flink 地址，</p>\n</li>\n<li>\n<p>最后在 Flink [0x08] 中得到 KERNEL32.DLL 模块的基地址。</p>\n</li>\n<li>\n<p>这种方法比较通用，适用于 2K/XP/2003。</p>\n</li>\n<li>\n<p>在 Exploit 的编写中，也通常采用这种方式。</p>\n</li>\n</ul>\n<p><strong>d.</strong> <strong>Stack 特定高端地址的数据</strong></p>\n<p>这种方法只适用于 Windows NT 操作系统，但这种方法的代码量是最小的，只有 25B。</p>\n<p>每个执行的线程都有它自己的 TEB (线程环境块)，该块中存储着线程的栈顶的地址，从该地址向下偏移 0X1C 处的地址肯定位于 Kernel32.dll 中。则可以通过该地址向低地址以 64KB 为单位来查找 Kernel32.dll 的基地址。</p>\n<p><strong>获取指定函数内存地址的方法：</strong></p>\n<p>通过 Address of Names 数组查找函数名，记录索引值</p>\n<p>在 Address of Name Ordinals 编号数组中找到这个索引值对应的编号</p>\n<p>在 Address of Functions 数组中以编号为索引即可找到指定函数的内存地址</p>\n<h4 id=\"3-目标检索目标程序遍历搜索全盘查找或者部分盘符查找\"><a class=\"anchor\" href=\"#3-目标检索目标程序遍历搜索全盘查找或者部分盘符查找\">#</a> (3) 目标检索（目标程序遍历搜索）：全盘查找，或者部分盘符查找</h4>\n<ol>\n<li>\n<p>指定找到的目录为当前工作目录</p>\n</li>\n<li>\n<p>开始搜索文件 (*.*)</p>\n</li>\n<li>\n<p>该目录搜索完毕？是则返回，否则继续</p>\n</li>\n<li>\n<p>找到文件还是目录？是目录则调用自身函数 FindFile，否则继续</p>\n</li>\n<li>\n<p>是文件，如符合感染条件，则调用感染模块，否则继续</p>\n</li>\n<li>\n<p>搜索下一个文件 (FindNextFile)，转到 3 继续</p>\n</li>\n</ol>\n<h4 id=\"4-感染模块病毒代码插入位置选择与写入控制权返回机制\"><a class=\"anchor\" href=\"#4-感染模块病毒代码插入位置选择与写入控制权返回机制\">#</a> (4) 感染模块：病毒代码插入位置选择与写入，控制权返回机制</h4>\n<p>关键：病毒代码能够得到运行；程序的正常功能不能被破坏</p>\n<p>代码插入位置：添加新节；碎片式感染；插入式感染；伴随式感染。</p>\n<h2 id=\"重定位方法简单汇编语言理解\"><a class=\"anchor\" href=\"#重定位方法简单汇编语言理解\">#</a> 重定位方法（简单汇编语言理解）</h2>\n<p>计算正确地址与错误地址的偏差，并保存到全局寄存器中；当使用病毒变量时，与该值进行加运算，完成修正。</p>\n<p><img data-src=\"image-6.png\" alt=\"Alt text\" /></p>\n<p><img data-src=\"image-7.png\" alt=\"Alt text\" /></p>\n<p><img data-src=\"image-8.png\" alt=\"Alt text\" /></p>\n<p>校正值 = 真实地址（call 的） – 预期地址（offset）</p>\n<p>使用时用变量的预期地址（offset） + 校正值</p>\n<h2 id=\"增加新节感染的步骤\"><a class=\"anchor\" href=\"#增加新节感染的步骤\">#</a> 增加新节感染的步骤</h2>\n<p>感染文件的基本步骤：</p>\n<ol>\n<li>\n<p>判断目标文件开始的两个字节是否为 &quot;MZ&quot;。</p>\n</li>\n<li>\n<p>判断 PE 文件标记 &quot;PE&quot;。</p>\n</li>\n<li>\n<p>判断感染标记，如果已被感染过则跳出继续执行 HOST 程序，否则继续。</p>\n</li>\n<li>\n<p>获得 Directory（数据目录）的个数，（每个数据目录信息占 8 个字节）。</p>\n</li>\n<li>\n<p>得到节表起始位置。(Directory 的偏移地址 + 数据目录占用的字节数 = 节表起始位置)</p>\n</li>\n<li>\n<p>得到目前最后节表的末尾偏移（紧接其后用于写入一个新的病毒节）节表起始位置 + 节的个数 * 28H (每个节表占用的字节数 28H)= 目前最后节表的末尾偏移。</p>\n</li>\n<li>\n<p>开始写入节表和病毒节</p>\n</li>\n<li>\n<p>修正文件头信息</p>\n</li>\n</ol>\n<h2 id=\"捆绑式感染优缺点\"><a class=\"anchor\" href=\"#捆绑式感染优缺点\">#</a> 捆绑式感染（优缺点）</h2>\n<p>定义：将 HOST 作为数据存储在病毒体内，当执行病毒程序时，还原并执行 HOST 文件。</p>\n<p>例子：熊猫烧香病毒</p>\n<p>优点：编写简单、效率高。可感染自校验程序。</p>\n<p>缺点：被感染后的程序主体是病毒程序，易被发现（程序叠加＋释放执行），程序图标问题。</p>\n<h2 id=\"汇编病毒实验-kernel32dll基地址定位代码\"><a class=\"anchor\" href=\"#汇编病毒实验-kernel32dll基地址定位代码\">#</a> 汇编病毒实验 - kernel32.dll 基地址定位代码</h2>\n<p>实验采用的是利用程序的返回地址遍历（？）的方法。</p>\n<p><figure class=\"highlight armasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"symbol\">GetKernelBase</span> <span class=\"meta\">proc</span> dwKernelRet:     <span class=\"comment\">;定义一个过程（函数）名为GetKernelBase，接受一个参数dwKernelRet。  </span></span><br><span class=\"line\"><span class=\"symbol\">LOCAL</span> dwReturn:                     <span class=\"comment\">;定义一个局部变量dwReturn。  </span></span><br><span class=\"line\"><span class=\"symbol\">pushad:</span>                             <span class=\"comment\">;将所有通用寄存器的值压入堆栈。  </span></span><br><span class=\"line\"><span class=\"symbol\">call</span> Relocate:                      <span class=\"comment\">;调用Relocate过程。这可能是一个子过程，但是在提供的代码中并没有给出具体的实现。  </span></span><br><span class=\"line\"><span class=\"symbol\">assume</span> fs:nothing:                  <span class=\"comment\">;指定FS段寄存器的偏移为0。  </span></span><br><span class=\"line\"><span class=\"keyword\">push</span> ebp:                           <span class=\"comment\">;将EBP寄存器的值压入堆栈。  </span></span><br><span class=\"line\"><span class=\"symbol\">lea</span> eax,[ebx + offset PageError]:   <span class=\"comment\">;计算PageError标签的地址并将其存储在EAX寄存器中。  </span></span><br><span class=\"line\"><span class=\"keyword\">push</span> eax:                           <span class=\"comment\">;将EAX寄存器的值压入堆栈。  </span></span><br><span class=\"line\"><span class=\"symbol\">lea</span> eax,[ebx + offset SEHHandler]:  <span class=\"comment\">;计算SEHHandler标签的地址并将其存储在EAX寄存器中。  </span></span><br><span class=\"line\"><span class=\"keyword\">push</span> eax:                           <span class=\"comment\">;将EAX寄存器的值压入堆栈。  </span></span><br><span class=\"line\"><span class=\"keyword\">push</span> fs:[<span class=\"number\">0</span>]:                        <span class=\"comment\">;将FS段寄存器的值（之前通过assume fs:nothing指定为0）压入堆栈。  </span></span><br><span class=\"line\"><span class=\"keyword\">mov</span> fs:[<span class=\"number\">0</span>], esp:                    <span class=\"comment\">;将堆栈指针的值存储到FS段寄存器的偏移0处。  </span></span><br><span class=\"line\"><span class=\"keyword\">mov</span> edi, dwKernelRet:               <span class=\"comment\">;将传入的参数dwKernelRet的值存储到EDI寄存器。  </span></span><br><span class=\"line\"><span class=\"keyword\">and</span> edi, <span class=\"number\">0</span>ffff0000h:                <span class=\"comment\">;将EDI寄存器的值按位与0xffff0000，保留高16位，清零低16位。这样做可能是为了获得模块的基地址，因为模块基地址通常在PE头中的高16位。  </span></span><br><span class=\"line\"><span class=\"comment\">@@::                                ;定义一个标签。  </span></span><br><span class=\"line\"><span class=\"keyword\">cmp</span> word ptr [edi], IMAGE_DOS_SIGNATURE: <span class=\"comment\">;比较edi指向的地址处的16位值与IMAGE_DOS_SIGNATURE（表示DOS头的标志）是否相等。  </span></span><br><span class=\"line\"><span class=\"symbol\">jne</span> PageError:                      <span class=\"comment\">;如果不相等，跳转到PageError标签。  </span></span><br><span class=\"line\"><span class=\"keyword\">mov</span> esi, edi:                       <span class=\"comment\">;将edi的值复制到esi寄存器。  </span></span><br><span class=\"line\"><span class=\"keyword\">add</span> esi, [esi+<span class=\"number\">003</span>ch]:               <span class=\"comment\">;计算esi寄存器指向的地址处的值（PE头中的e_lfanew字段）加上esi的值，得到PE头的地址。  </span></span><br><span class=\"line\"><span class=\"keyword\">cmp</span> word ptr [esi], IMAGE_NT_SIGNATURE: <span class=\"comment\">;比较esi指向的地址处的16位值与IMAGE_NT_SIGNATURE（表示NT头的标志）是否相等。  </span></span><br><span class=\"line\"><span class=\"symbol\">jne</span> PageError:                      <span class=\"comment\">;如果不相等，跳转到PageError标签。  </span></span><br><span class=\"line\"><span class=\"keyword\">mov</span> dwReturn, edi:                  <span class=\"comment\">;将edi的值存储到dwReturn局部变量中。  </span></span><br><span class=\"line\"><span class=\"symbol\">jmp</span> <span class=\"comment\">@@:                             ;无条件跳转到@@标签。  </span></span><br><span class=\"line\"><span class=\"symbol\">PageError:</span>:                         <span class=\"comment\">;定义PageError标签。  </span></span><br><span class=\"line\"><span class=\"keyword\">sub</span> edi, <span class=\"number\">010000</span>h:                   <span class=\"comment\">;将edi的值减去0x10000。  </span></span><br><span class=\"line\"><span class=\"keyword\">cmp</span> edi, <span class=\"number\">070000000</span>h:                <span class=\"comment\">;比较edi的值与0x70000000。  </span></span><br><span class=\"line\"><span class=\"symbol\">jb</span> <span class=\"comment\">@@:                              ;如果edi的值小于0x70000000，无条件跳转到@@标签。  </span></span><br><span class=\"line\"><span class=\"symbol\">jmp</span> <span class=\"comment\">@b:                             ;无条件跳转到上一个标签@b。  </span></span><br><span class=\"line\"><span class=\"comment\">@@::                                ;定义一个标签。  </span></span><br><span class=\"line\"><span class=\"keyword\">pop</span> fs:[<span class=\"number\">0</span>]:                         <span class=\"comment\">;弹出堆栈中的值并存储到FS段寄存器的偏移0处。  </span></span><br><span class=\"line\"><span class=\"keyword\">add</span> esp, <span class=\"number\">0</span>ch:                       <span class=\"comment\">;调整堆栈指针，相当于释放12字节的空间。  </span></span><br><span class=\"line\"><span class=\"symbol\">popad:</span>                              <span class=\"comment\">;弹出之前压入堆栈的所有通用寄存器的值。  </span></span><br><span class=\"line\"><span class=\"keyword\">mov</span> eax, dwReturn:                  <span class=\"comment\">;将dwReturn的值存储到EAX寄存器。  </span></span><br><span class=\"line\"><span class=\"symbol\">ret:</span>                                <span class=\"comment\">;返回，结束过程。  </span></span><br><span class=\"line\"><span class=\"comment\">;总体来说，该函数的目的是通过对模块的DOS头和NT头的签名进行验证，获取Kernel.dll模块的加载基地址，并将其存储在dwReturn变量中返回。 </span></span><br><span class=\"line\"> </span><br></pre></td></tr></table></figure></p>\n<h2 id=\"汇编病毒实验-得到kernel基地址后根据函数名获取函数地址的流程\"><a class=\"anchor\" href=\"#汇编病毒实验-得到kernel基地址后根据函数名获取函数地址的流程\">#</a> 汇编病毒实验 - 得到 kernel 基地址后，根据函数名获取函数地址的流程</h2>\n<p><figure class=\"highlight armasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">mov</span>     esi, hModule              <span class=\"comment\">; 设置 esi 为模块句柄</span></span><br><span class=\"line\"><span class=\"keyword\">add</span>     esi, [esi + <span class=\"number\">3</span>ch]          <span class=\"comment\">; 获取 IMAGE\\_NT\\_HEADERS 结构的地址</span></span><br><span class=\"line\"><span class=\"symbol\">assume</span>  esi:ptr IMAGE\\_NT\\_HEADERS  <span class=\"comment\">; 假设 esi 指向 IMAGE\\_NT\\_HEADERS 结构</span></span><br><span class=\"line\"><span class=\"keyword\">mov</span>     esi, [esi].OptionalHeader.DataDirectory.VirtualAddress <span class=\"comment\">; 获取导出表的 RVA</span></span><br><span class=\"line\"><span class=\"keyword\">add</span>     esi, hModule              <span class=\"comment\">; 计算导出表的地址</span></span><br><span class=\"line\"><span class=\"symbol\">assume</span>  esi:ptr IMAGE\\_<span class=\"meta\">EXPORT</span>\\_DIRECTORY <span class=\"comment\">; 假设 esi 指向 IMAGE\\_EXPORT\\_DIRECTORY 结构</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">mov</span>     ebx, [esi].AddressOfNames <span class=\"comment\">; 获取导出函数名称表的 RVA</span></span><br><span class=\"line\"><span class=\"keyword\">add</span>     ebx, hModule              <span class=\"comment\">; 计算导出函数名称表的地址</span></span><br><span class=\"line\"><span class=\"symbol\">xor</span>     edx, edx                  <span class=\"comment\">; 清零 edx，用于计数</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">@@:</span></span><br><span class=\"line\"><span class=\"keyword\">push</span>    esi                       <span class=\"comment\">; 保存 esi 的值</span></span><br><span class=\"line\"><span class=\"keyword\">mov</span>     edi, [ebx]                <span class=\"comment\">; 获取当前导出函数的名称 RVA</span></span><br><span class=\"line\"><span class=\"keyword\">add</span>     edi, hModule              <span class=\"comment\">; 计算当前导出函数的地址</span></span><br><span class=\"line\"><span class=\"keyword\">mov</span>     esi, lpszApi              <span class=\"comment\">; 设置 esi 为要查找的函数名</span></span><br><span class=\"line\"><span class=\"keyword\">mov</span>     ecx, dwStringLength       <span class=\"comment\">; 设置 ecx 为字符串长度</span></span><br><span class=\"line\"><span class=\"symbol\">repz</span>    cmpsb                      <span class=\"comment\">; 逐字节比较当前导出函数名和目标函数名</span></span><br><span class=\"line\"><span class=\"symbol\">jnz</span>     skip                       <span class=\"comment\">; 如果不相等，则跳转到 skip 标签</span></span><br><span class=\"line\"><span class=\"keyword\">pop</span>     esi                       <span class=\"comment\">; 恢复 esi 的值</span></span><br><span class=\"line\"><span class=\"symbol\">jmp</span>     <span class=\"comment\">@f                        ; 跳转到结束标签</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"symbol\">skip:</span></span><br><span class=\"line\"><span class=\"keyword\">pop</span>     esi                       <span class=\"comment\">; 恢复 esi 的值</span></span><br><span class=\"line\"><span class=\"keyword\">add</span>     ebx, <span class=\"number\">4</span>                    <span class=\"comment\">; 移到下一个导出函数的名称</span></span><br><span class=\"line\"><span class=\"symbol\">inc</span>     edx                       <span class=\"comment\">; 增加计数</span></span><br><span class=\"line\"><span class=\"keyword\">cmp</span>     edx, [esi].NumberOfNames  <span class=\"comment\">; 比较计数和导出函数的总数</span></span><br><span class=\"line\"><span class=\"symbol\">jl</span>      <span class=\"comment\">@@b                       ; 如果计数小于总数，继续循环</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"symbol\">jmp</span>     Error                      <span class=\"comment\">; 如果没有找到匹配的函数名，跳转到错误处理</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">@@:</span></span><br><span class=\"line\"><span class=\"keyword\">sub</span>     ebx, [esi].AddressOfNames <span class=\"comment\">; 计算当前导出函数名表的偏移量</span></span><br><span class=\"line\"><span class=\"keyword\">sub</span>     ebx, hModule               <span class=\"comment\">; 计算当前导出函数名表的 RVA</span></span><br><span class=\"line\"><span class=\"symbol\">shr</span>     ebx, <span class=\"number\">1</span>                     <span class=\"comment\">; 将偏移量右移一位（除以2）</span></span><br><span class=\"line\"><span class=\"keyword\">add</span>     ebx, [esi].AddressOfNameOrdinals <span class=\"comment\">; 获取当前导出函数名的序数表的 RVA</span></span><br><span class=\"line\"><span class=\"keyword\">add</span>     ebx, hModule               <span class=\"comment\">; 计算当前导出函数名的序数表的地址</span></span><br><span class=\"line\"><span class=\"symbol\">movzx</span>   eax, word ptr [ebx]       <span class=\"comment\">; 获取当前导出函数的序数</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"symbol\">shl</span>     eax, <span class=\"number\">2</span>                     <span class=\"comment\">; 将序数左移两位（乘以4）</span></span><br><span class=\"line\"><span class=\"keyword\">add</span>     eax, [esi].AddressOfFunctions <span class=\"comment\">; 获取当前导出函数地址表的 RVA</span></span><br><span class=\"line\"><span class=\"keyword\">add</span>     eax, hModule               <span class=\"comment\">; 计算当前导出函数的 RVA</span></span><br><span class=\"line\"><span class=\"keyword\">mov</span>     eax, [eax]                 <span class=\"comment\">; 获取当前导出函数的地址</span></span><br><span class=\"line\"><span class=\"keyword\">add</span>     eax, hModule               <span class=\"comment\">; 计算当前导出函数的地址</span></span><br><span class=\"line\"><span class=\"keyword\">mov</span>     dwReturn, eax              <span class=\"comment\">; 保存当前导出函数的地址</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"symbol\">Error:</span></span><br><span class=\"line\"><span class=\"keyword\">pop</span>     fs:[<span class=\"number\">0</span>]                     <span class=\"comment\">; 恢复异常处理程序</span></span><br><span class=\"line\"><span class=\"keyword\">add</span>     esp, <span class=\"number\">0</span>ch                   <span class=\"comment\">; 调整堆栈</span></span><br><span class=\"line\"><span class=\"symbol\">assume</span>  esi:nothing                <span class=\"comment\">; 取消 esi 的假设</span></span><br><span class=\"line\"><span class=\"symbol\">popad</span>                             <span class=\"comment\">; 恢复寄存器的值</span></span><br><span class=\"line\"><span class=\"keyword\">mov</span>     eax, dwReturn              <span class=\"comment\">; 返回当前导出函数的地址</span></span><br><span class=\"line\"><span class=\"symbol\">ret</span></span><br></pre></td></tr></table></figure><br />\n 以上是函数地址计算的过程。代码首先获取导出表的地址，然后通过遍历导出函数名称表找到目标函数名的序数，再通过序数找到导出函数地址表，最终获取目标函数的地址。如果找到匹配的函数名，就会跳转到结束标签，否则跳转到错误处理。在错误处理中，异常处理程序被恢复，堆栈被调整，最终返回找到的函数地址或错误状态。</p>\n<h1 id=\"第六章\"><a class=\"anchor\" href=\"#第六章\">#</a> 第六章</h1>\n<h2 id=\"宏病毒如何获得控制权\"><a class=\"anchor\" href=\"#宏病毒如何获得控制权\">#</a> 宏病毒如何获得控制权</h2>\n<p>利用自动执行宏，将病毒代码写入，从而获取控制权。</p>\n<p>当打开文档，其中的宏就会被执行，宏病毒就会被激活，并驻留在 Normal 模板上。</p>\n<p>所有自动保存的文档都会 &quot;感染&quot; 上这种宏病毒，而且如果其他用户打开了感染病毒的文档，宏病毒又会转移到他的计算机上。</p>\n<h2 id=\"宏-自我保护\"><a class=\"anchor\" href=\"#宏-自我保护\">#</a> 宏 - 自我保护</h2>\n<ul>\n<li>禁止提示信息</li>\n<li>屏蔽命令菜单，不允许查看宏</li>\n<li>隐藏宏的真实病毒代码</li>\n</ul>\n<h2 id=\"宏-导出导入\"><a class=\"anchor\" href=\"#宏-导出导入\">#</a> 宏 - 导出导入</h2>\n<p><img data-src=\"image-9.png\" alt=\"Alt text\" /></p>\n<h2 id=\"脚本病毒感染的方法\"><a class=\"anchor\" href=\"#脚本病毒感染的方法\">#</a> 脚本病毒感染的方法</h2>\n<p>VBS 脚本病毒：用 VBScript 编写，能够进行自我传播的破坏性程序，其需要人工干预触发执行。</p>\n<p>方法：VBS 脚本病毒是直接通过自我复制来感染文件的，病毒中的绝大部分代码都可以直接附加在其他同类程序的中间。</p>\n<h2 id=\"vbs脚本病毒对抗反病毒软件的几种技巧\"><a class=\"anchor\" href=\"#vbs脚本病毒对抗反病毒软件的几种技巧\">#</a> VBS 脚本病毒对抗反病毒软件的几种技巧</h2>\n<ul>\n<li>自加密</li>\n<li>运用 Execute 函数：如果病毒将这段声明代码转化为字符串，然后通过 Execute (String) 函数执行，就可以躲避某些反病毒软件。</li>\n<li>改变对象声明方法：如 fso=createobject (&quot;script&quot;＋&quot;ing.filesyste&quot;＋&quot;mobject&quot;)</li>\n<li>关闭反病毒软件</li>\n</ul>\n<h1 id=\"第七章\"><a class=\"anchor\" href=\"#第七章\">#</a> 第七章</h1>\n<h1 id=\"第八章\"><a class=\"anchor\" href=\"#第八章\">#</a> 第八章</h1>\n<h1 id=\"第九章\"><a class=\"anchor\" href=\"#第九章\">#</a> 第九章</h1>\n<p>检测对象：引导扇区、文件系统中可能带毒的文件、内存空间、主板 BIOS、网络流量和系统行为等。</p>\n<p>检测策略：专用检查技术（如文本特征值检测技术）、通用检查技术（如启发式扫描技术、主动防御技术）</p>\n<h2 id=\"bm算法\"><a class=\"anchor\" href=\"#bm算法\">#</a> BM 算法</h2>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTYxNjI4NS9hcnRpY2xlL2RldGFpbHMvMTI4MTk4NzYyP29wc19yZXF1ZXN0X21pc2M9JTI1N0IlMjUyMnJlcXVlc3QlMjU1RmlkJTI1MjIlMjUzQSUyNTIyMTcwNTA2MDYwMzE2ODAwMTg4NTExNzg0JTI1MjIlMjUyQyUyNTIyc2NtJTI1MjIlMjUzQSUyNTIyMjAxNDA3MTMuMTMwMTAyMzM0Li4lMjUyMiUyNTdEJmFtcDtyZXF1ZXN0X2lkPTE3MDUwNjA2MDMxNjgwMDE4ODUxMTc4NCZhbXA7Yml6X2lkPTAmYW1wO3V0bV9tZWRpdW09ZGlzdHJpYnV0ZS5wY19zZWFyY2hfcmVzdWx0Lm5vbmUtdGFzay1ibG9nLTJ+YWxsfnRvcF9jbGlja35kZWZhdWx0LTItMTI4MTk4NzYyLW51bGwtbnVsbC4xNDIlNUV2OTklNUVwY19zZWFyY2hfcmVzdWx0X2Jhc2UxJmFtcDt1dG1fdGVybT1CTSVFNyVBRSU5NyVFNiVCMyU5NSZhbXA7c3BtPTEwMTguMjIyNi4zMDAxLjQxODc=\">BM (Boyer-Moore) 算法详解_bm 算法 - CSDN 博客</span></p>\n<h2 id=\"ac算法\"><a class=\"anchor\" href=\"#ac算法\">#</a> AC 算法</h2>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg0NjEzOS9hcnRpY2xlL2RldGFpbHMvMTA1MDc1Njc2P29wc19yZXF1ZXN0X21pc2M9JmFtcDtyZXF1ZXN0X2lkPSZhbXA7Yml6X2lkPTEwMiZhbXA7dXRtX3Rlcm09QUMlRTclQUUlOTclRTYlQjMlOTUmYW1wO3V0bV9tZWRpdW09ZGlzdHJpYnV0ZS5wY19zZWFyY2hfcmVzdWx0Lm5vbmUtdGFzay1ibG9nLTJ+YWxsfnNvYmFpZHV3ZWJ+ZGVmYXVsdC05LTEwNTA3NTY3Ni4xNDIlNUV2OTklNUVwY19zZWFyY2hfcmVzdWx0X2Jhc2UxJmFtcDtzcG09MTAxOC4yMjI2LjMwMDEuNDE4Nw==\">AC 自动机 算法详解 (图解) 及模板_ac 算法图解 - CSDN 博客</span></p>\n<h2 id=\"wu-manber算法\"><a class=\"anchor\" href=\"#wu-manber算法\">#</a> Wu-Manber 算法</h2>\n<p>建表：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BpOW5jL2FydGljbGUvZGV0YWlscy85MTI0NjIz\">Wu-Manber 经典多模式匹配算法_wumanber-CSDN 博客</span></p>\n<p>匹配：<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbGFkYXduL3AvOTI4MTUwOS5odG1s\">浅谈</span><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbGFkYXduL3AvOTI4MTUwOS5odG1s\"> WM 算法 - IvanB.G.Liu - 博客园 (cnblogs.com)</span></p>\n<h2 id=\"校验和检测\"><a class=\"anchor\" href=\"#校验和检测\">#</a> 校验和检测</h2>\n<p>思路：病毒会通过更改文件来工作运行 (除了伴生病毒外不需要），可以用完整性检查器，通过监视对文件进行未经授权的更改，来利用此行为，来查找病毒。</p>\n<p>实用方法：</p>\n<ul>\n<li>脱机检测。校验和仅定期验证，例如每周一次。</li>\n<li>自检。可执行文件被修改为在运行时检查自己。</li>\n<li>完整性壳层。可执行文件的校验和在执行前立即进行验证。</li>\n</ul>\n<p>检测对象：</p>\n<ul>\n<li>文件头部：在文件很大的情况下为节省时间只对头部进行校验</li>\n<li>文件属性：检查文件长度、创建时间、读写属性、首簇号等</li>\n<li>文件内容：检查整个文件</li>\n<li>系统数据：检查引导扇区、中断向量表、驱动程序处理例程等</li>\n</ul>\n<p>优缺点：</p>\n<ul>\n<li>\n<p>优点：方法简单，能够发现未知病毒，能够发现文件的微小变化</p>\n</li>\n<li>\n<p>缺点：必须先保存正确的校验码，容易误报，效率低，不能识别病毒类别</p>\n</li>\n</ul>\n<h2 id=\"系统调用dll名称及对应功能\"><a class=\"anchor\" href=\"#系统调用dll名称及对应功能\">#</a> 系统调用 DLL 名称及对应功能</h2>\n<ul>\n<li>\n<p>Kernel32.dll 常见的核心系统功能，如访问和操作内存、文件和硬件</p>\n</li>\n<li>\n<p>Ntdll.dll Windows 内核的接口</p>\n</li>\n<li>\n<p>User32.dll 用户界面</p>\n</li>\n<li>\n<p>Advapi32.dll 服务管理器和注册表组件</p>\n</li>\n<li>\n<p>Gdi32.dll 图形显示和操作</p>\n</li>\n<li>\n<p>Wsock32.dll Ws2_32.dll 联网</p>\n</li>\n<li>\n<p>Wininet.dll 更高层次的网络函数，实现了如 FTP、HTTP 和 NTP</p>\n</li>\n</ul>\n<p><img data-src=\"image-10.png\" alt=\"Alt text\" /></p>\n<h1 id=\"第十章\"><a class=\"anchor\" href=\"#第十章\">#</a> 第十章</h1>\n<h2 id=\"软件缺陷与漏洞机理基础\"><a class=\"anchor\" href=\"#软件缺陷与漏洞机理基础\">#</a> 软件缺陷与漏洞机理基础</h2>\n<h3 id=\"软件漏洞定义及其要素\"><a class=\"anchor\" href=\"#软件漏洞定义及其要素\">#</a> 软件漏洞定义及其要素</h3>\n<ul>\n<li>\n<p>定义：漏洞 (Vulnerability)，通常也称脆弱性，RFC2828 将漏洞定义为 &quot;系统设计、实现或操作管理中存在的缺陷或者弱点，能被利用而违背系统的安全策略&quot;。攻击者利用漏洞可以获得计算机系统的额外权限。</p>\n</li>\n<li>\n<p>要素：①受影响的软件版本②POC - 验证漏洞存在的代码③漏洞触发的条件④攻击能力</p>\n</li>\n</ul>\n<h3 id=\"漏洞威胁分类\"><a class=\"anchor\" href=\"#漏洞威胁分类\">#</a> 漏洞威胁分类</h3>\n<ul>\n<li>获取访问权限的漏洞</li>\n<li>权限提升的漏洞</li>\n<li>拒绝服务的漏洞</li>\n<li>恶意软件植入漏洞</li>\n<li>数据丢失或者泄露漏洞</li>\n</ul>\n<h3 id=\"软件漏洞生命周期\"><a class=\"anchor\" href=\"#软件漏洞生命周期\">#</a> 软件漏洞生命周期</h3>\n<p>漏洞挖掘→漏洞重现→漏洞诊断→漏洞修复→补丁测试→补丁推送</p>\n<p><img data-src=\"image-11.png\" alt=\"Alt text\" /></p>\n<h3 id=\"漏洞利用对软件系统的威胁\"><a class=\"anchor\" href=\"#漏洞利用对软件系统的威胁\">#</a> 漏洞利用对软件系统的威胁</h3>\n<ul>\n<li>\n<p>非法获得访问权限：未经授权使用资源</p>\n</li>\n<li>\n<p>权限提升：用户账号从低权限提升到高权限</p>\n</li>\n<li>\n<p>拒绝服务：使得计算机软件或者系统无法正常工作、无法提供正常的服务（本地 / 远程）</p>\n</li>\n<li>\n<p>恶意软件植入：主动（不需要用户的干预）/ 被动（需要借助用户的操作）</p>\n</li>\n<li>\n<p>数据丢失或者泄露：数据被破坏、删除或者非法读取</p>\n</li>\n</ul>\n<h2 id=\"栈缓冲区溢出\"><a class=\"anchor\" href=\"#栈缓冲区溢出\">#</a> 栈缓冲区溢出</h2>\n<h3 id=\"栈区的内容\"><a class=\"anchor\" href=\"#栈区的内容\">#</a> 栈区的内容</h3>\n<ul>\n<li>函数的参数</li>\n<li>函数返回地址</li>\n<li>EBP 的值</li>\n<li>一些通用寄存器的值</li>\n<li>当前正在执行的函数的局部变量</li>\n</ul>\n<h3 id=\"栈操作\"><a class=\"anchor\" href=\"#栈操作\">#</a> 栈操作</h3>\n<p>push/pop</p>\n<h3 id=\"函数调用过程与栈分布图\"><a class=\"anchor\" href=\"#函数调用过程与栈分布图\">#</a> 函数调用过程与栈分布图</h3>\n<p>调用过程与栈分布图：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jbG91ZC50ZW5jZW50LmNvbS9kZXZlbG9wZXIvYXJ0aWNsZS8xODE0NjEz\">C++ 函数调用过程深入分析 - 腾讯云开发者社区 - 腾讯云 (tencent.com)</span></p>\n<h4 id=\"1-__cdecl-c调用规则\"><a class=\"anchor\" href=\"#1-__cdecl-c调用规则\">#</a> (1) __cdecl C 调用规则</h4>\n<p>后面的参数先进入堆栈；</p>\n<p>函数返回后调用者负责清除堆栈，因此会生成较大的可执行程序。</p>\n<h4 id=\"2-__stdcall又称为winapi调用规则\"><a class=\"anchor\" href=\"#2-__stdcall又称为winapi调用规则\">#</a> (2) __stdcall（又称为 WINAPI）调用规则</h4>\n<p>后面的参数先进入堆栈；</p>\n<p>被调用的函数在返回前自行清理堆栈，所以生成的代码比 cdecl 小。</p>\n<h4 id=\"3-fast-call\"><a class=\"anchor\" href=\"#3-fast-call\">#</a> (3) Fast call</h4>\n<p>把函数参数的前两个放入寄存器，其他参数入栈（后面参数先入）</p>\n<h4 id=\"4-pascal\"><a class=\"anchor\" href=\"#4-pascal\">#</a> (4) Pascal</h4>\n<p>参数在前的先入栈（主要用在 WIN16 函数库，现在基本不用）</p>\n<p>不支持可变参数的函数调用。</p>\n<h3 id=\"覆盖返回地址\"><a class=\"anchor\" href=\"#覆盖返回地址\">#</a> 覆盖返回地址</h3>\n<p>Nrs + jmp esp</p>\n<h3 id=\"覆盖seh中的handler\"><a class=\"anchor\" href=\"#覆盖seh中的handler\">#</a> 覆盖 SEH 中的 handler</h3>\n<p>fs:[0] 指向 SEH 的初始地址，通过获取该地址以确定溢出的长度，这个长度必须确定以保证能够正确覆盖关键函数指针。将指针覆盖为类似于 jmp esp 指令的地址，即可执行 shellcode。</p>\n<h2 id=\"堆缓冲区溢出\"><a class=\"anchor\" href=\"#堆缓冲区溢出\">#</a> 堆缓冲区溢出</h2>\n<p>既然堆是操作系统分配给进程的内存段，两个程序在动态执行中申请到的堆地址可能是一样的吗？所处物理内存上的物理地址可能是一样的吗？</p>\n<p>注意：两个程序动态申请的堆空间地址完全有可能相同。要搞清楚虚拟地址和物理地址的区别，程序中直接操作的是虚拟内存地址，由操作系统从物理地址中映射而来，并非物理内存地址。但两个程序分配的堆地址的物理地址也有可能相同。两个程序可以交错使用这块内存。</p>\n<h3 id=\"堆表空表和快表\"><a class=\"anchor\" href=\"#堆表空表和快表\">#</a> 堆表：空表和快表</h3>\n<ul>\n<li>\n<p>Freelist（空表）：双向链表</p>\n<ul>\n<li>\n<p>128 项（0&lt;=index&lt;128）</p>\n</li>\n<li>\n<p>空闲块大小 = {8 * index，0 &lt; index &lt; 128；1024，index = 0}</p>\n</li>\n</ul>\n</li>\n<li>\n<p>Lookaside（快表）：单向链表</p>\n<ul>\n<li>\n<p>128 项 每项最多 4 个节点</p>\n</li>\n<li>\n<p>链中的堆不发生合并</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"堆块块首和块首\"><a class=\"anchor\" href=\"#堆块块首和块首\">#</a> 堆块：块首和块首</h3>\n<p>块首：头部几个字节，用来标识自身信息（如大小，空闲还是占有等）</p>\n<p>块身：数据存储区域，紧跟块首</p>\n<h3 id=\"堆溢出的利用方式\"><a class=\"anchor\" href=\"#堆溢出的利用方式\">#</a> 堆溢出的利用方式</h3>\n<h4 id=\"1-whatwhere或dword-shoot\"><a class=\"anchor\" href=\"#1-whatwhere或dword-shoot\">#</a> (1) What→where 或 Dword shoot</h4>\n<p>分配完 buf1 之后向其中拷贝内容，拷贝的内容大小超过 buf1 的大小，即 16 字节，就会发生溢出，如果覆盖掉两个 4 字节的指针，而下一次分配 buf2 之前又没有把 buf1 释放掉的话，就会把一个 4 字节的内容写入一个地址当中，而这个内容和地址都是能够控制的，这样就可以控制函数的流程转向 shellcode。</p>\n<h4 id=\"2-堆溢出能够利用成功的前提条件\"><a class=\"anchor\" href=\"#2-堆溢出能够利用成功的前提条件\">#</a> (2) 堆溢出能够利用成功的前提条件</h4>\n<h4 id=\"3-堆喷射利用原理\"><a class=\"anchor\" href=\"#3-堆喷射利用原理\">#</a> (3) 堆喷射利用原理</h4>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MTYxOTkzL2FydGljbGUvZGV0YWlscy8xMDQ4NDY3OTI/b3BzX3JlcXVlc3RfbWlzYz0lMjU3QiUyNTIycmVxdWVzdCUyNTVGaWQlMjUyMiUyNTNBJTI1MjIxNzA1MjA4Mzc5MTY4MDAxODIxOTUxODQlMjUyMiUyNTJDJTI1MjJzY20lMjUyMiUyNTNBJTI1MjIyMDE0MDcxMy4xMzAxMDIzMzQuLiUyNTIyJTI1N0QmYW1wO3JlcXVlc3RfaWQ9MTcwNTIwODM3OTE2ODAwMTgyMTk1MTg0JmFtcDtiaXpfaWQ9MCZhbXA7dXRtX21lZGl1bT1kaXN0cmlidXRlLnBjX3NlYXJjaF9yZXN1bHQubm9uZS10YXNrLWJsb2ctMn5hbGx+c29iYWlkdWVuZH5kZWZhdWx0LTEtMTA0ODQ2NzkyLW51bGwtbnVsbC4xNDIlNUV2OTklNUVwY19zZWFyY2hfcmVzdWx0X2Jhc2UxJmFtcDt1dG1fdGVybT0lRTUlQTAlODYlRTUlOTYlQjclRTUlQjAlODQmYW1wO3NwbT0xMDE4LjIyMjYuMzAwMS40MTg3\">Heap Spray 原理_heap spaying-CSDN 博客</span></p>\n<h3 id=\"uaf基本原理与可能的安全问题\"><a class=\"anchor\" href=\"#uaf基本原理与可能的安全问题\">#</a> UAF 基本原理与可能的安全问题</h3>\n<p>如果攻击者可以操纵 p1，则在 p1 指向的内存被释放后，程序再次申请内存，由于 p1 没有被赋值为 NULL，攻击者可向 p1 指向的内存 写入精心构造的 Shellcode 或采用其他方式改变程序控制流，从而达到攻击的目的。</p>\n<h3 id=\"格式化字符串\"><a class=\"anchor\" href=\"#格式化字符串\">#</a> 格式化字符串</h3>\n<h4 id=\"1-格式化字符串函数printf的栈结构图\"><a class=\"anchor\" href=\"#1-格式化字符串函数printf的栈结构图\">#</a> (1) 格式化字符串函数 (printf) 的栈结构图</h4>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC80NjU4OTY1NDI=\">CTFer 成长日记 11：格式化字符串漏洞的原理与利用 - 知乎 (zhihu.com)</span></p>\n<h4 id=\"2-格式化字符串的危害\"><a class=\"anchor\" href=\"#2-格式化字符串的危害\">#</a> (2) 格式化字符串的危害</h4>\n<p>printf(&quot;%s%n&quot;, &quot;01234&quot;, &amp;n); // n = 5</p>\n<ul>\n<li>\n<p>越界读操作→数据泄露</p>\n</li>\n<li>\n<p>越界写操作→数据破坏</p>\n</li>\n</ul>\n<h2 id=\"整数溢出及其他漏洞类型\"><a class=\"anchor\" href=\"#整数溢出及其他漏洞类型\">#</a> 整数溢出及其他漏洞类型</h2>\n<h3 id=\"整数溢出的概念\"><a class=\"anchor\" href=\"#整数溢出的概念\">#</a> 整数溢出的概念</h3>\n<p>当试图保存一个比它可以表示的最大值还大的数时，就会发生整数溢出</p>\n<h3 id=\"整数溢出的典型表现形式需全部掌握\"><a class=\"anchor\" href=\"#整数溢出的典型表现形式需全部掌握\">#</a> 整数溢出的典型表现形式（需全部掌握）</h3>\n<ul>\n<li>\n<p>宽度溢出（short = int）</p>\n</li>\n<li>\n<p>运算溢出（乘法加法导致）</p>\n</li>\n<li>\n<p>符号溢出（负数）</p>\n</li>\n</ul>\n<h3 id=\"整数溢出和缓冲区溢出的经典结合形式\"><a class=\"anchor\" href=\"#整数溢出和缓冲区溢出的经典结合形式\">#</a> 整数溢出和缓冲区溢出的经典结合形式</h3>\n<h2 id=\"漏洞利用与发现\"><a class=\"anchor\" href=\"#漏洞利用与发现\">#</a> 漏洞利用与发现</h2>\n<h3 id=\"漏洞利用的目标\"><a class=\"anchor\" href=\"#漏洞利用的目标\">#</a> 漏洞利用的目标</h3>\n<ul>\n<li>修改内存变量</li>\n<li>修改代码逻辑</li>\n<li>修改函数的返回地址</li>\n<li>修改函数指针（C++）</li>\n<li>修改异常处理函数指针</li>\n<li>修改线程同步的函数指针</li>\n</ul>\n<h3 id=\"理解漏洞利用的整体流程\"><a class=\"anchor\" href=\"#理解漏洞利用的整体流程\">#</a> 理解漏洞利用的整体流程</h3>\n<ul>\n<li>定位漏洞点</li>\n<li>按照利用要求，编写 shellcode</li>\n<li>溢出，覆盖代码指针，使得 shellcode 获得可执行权</li>\n</ul>\n<h3 id=\"掌握shellcode实例运行原理\"><a class=\"anchor\" href=\"#掌握shellcode实例运行原理\">#</a> 掌握 shellcode 实例运行原理</h3>\n<h3 id=\"理解为什么需要地址重定位并能够说明重定位代码含义\"><a class=\"anchor\" href=\"#理解为什么需要地址重定位并能够说明重定位代码含义\">#</a> 理解为什么需要地址重定位，并能够说明重定位代码含义</h3>\n<p>由于 shellcode 没有 PE 头，因此 shellcode 中使用的 API 和数据必须由 shellcode 自己进行搜索和重定位</p>\n<h3 id=\"ascii-armoring\"><a class=\"anchor\" href=\"#ascii-armoring\">#</a> ASCII Armoring</h3>\n<p>ASCII armoring 机制想办法让 libc 所有函数的地址都包含一个零字节，让 strcpy 拷贝函数在遇到零地址时结束拷贝，攻击失败！</p>\n<p>攻击方法：ret2plt</p>\n<p>找到 4 个地址空间，它的首字节分别是 system 地址的第一个 byte, 第二个 byte，第三个 byte 和第四个 byte，然后一个个 byte 拷贝，将这 4 个 byte 拼凑到函数调用表里面。从而绕过直接拷贝 system 地址造成失败。</p>\n<h3 id=\"掌握二进制代码重用原理与示例具备rop分析与设计能力重点考察\"><a class=\"anchor\" href=\"#掌握二进制代码重用原理与示例具备rop分析与设计能力重点考察\">#</a> 掌握二进制代码重用原理与示例，具备 ROP 分析与设计能力（重点考察）</h3>\n<h3 id=\"静态分析技术vs动态分析技术\"><a class=\"anchor\" href=\"#静态分析技术vs动态分析技术\">#</a> 静态分析技术 VS 动态分析技术</h3>\n<p>动态分析：收集程序多次执行的运行过程的状态信息，结合输入和输出，检测程序存在的缺陷或漏洞。</p>\n<h1 id=\"第十一章\"><a class=\"anchor\" href=\"#第十一章\">#</a> 第十一章</h1>\n<h2 id=\"数据执行保护-depnx-防御机理及不足\"><a class=\"anchor\" href=\"#数据执行保护-depnx-防御机理及不足\">#</a> 数据执行保护 – DEP/NX 防御机理及不足</h2>\n<ul>\n<li>\n<p>防御机理：禁用 stack/heap 中的代码执行</p>\n</li>\n<li>\n<p>不足：带来兼容性、灵活性问题（如用于提取其他软件窗口上文字的软件，可能需要在栈或堆中执行代码，DEP 启用后这类软件可能无法正常运行。）</p>\n</li>\n<li>\n<p>对策：Ret2Libc、ROP、JOP、COP</p>\n</li>\n</ul>\n<h2 id=\"栈溢出保护-stack-guardstack-canary防御机理及不足\"><a class=\"anchor\" href=\"#栈溢出保护-stack-guardstack-canary防御机理及不足\">#</a> 栈溢出保护 – Stack Guard/Stack Canary 防御机理及不足</h2>\n<ul>\n<li>\n<p>防御机理：在函数开始时往栈中压入一个可以检验的随机数（ESP 异或.data 节的第一个 DWORD，这个 DWORD 称为种子，异或种子的结果作为 cookie），在函数结束时验证栈中的随机数是否一致。</p>\n</li>\n<li>\n<p>不足：无法防御的部分：未被保护的函数（不应用于以下情况：函数不包含缓冲区；函数被定义为具有变量参数列表；函数使用无保护的关键字标记；函数在第一个语句中包含内嵌汇编代码；缓冲区不是 8 字节类型且大小不大于 4 个字节），针对基于改写函数指针的攻击，如 C++ 虚函数攻击；针对异常处理机制的攻击；堆溢出攻击。</p>\n</li>\n<li>\n<p>对策：利用未保护的函数；覆盖 C++ 虚函数；攻击异常处理机制；同时替换栈和 data 中的 cookie</p>\n</li>\n</ul>\n<h2 id=\"地址空间分布随机化-aslr防御机理及不足\"><a class=\"anchor\" href=\"#地址空间分布随机化-aslr防御机理及不足\">#</a> 地址空间分布随机化 – ASLR 防御机理及不足</h2>\n<p>栈和堆的基址是加载时随机确定的；程序自身和关联库的基址是加载时随机确定的。</p>\n<p>兼容性：一些老处理器不支持。</p>\n<h1 id=\"第十二章\"><a class=\"anchor\" href=\"#第十二章\">#</a> 第十二章</h1>\n<h2 id=\"威胁建模过程\"><a class=\"anchor\" href=\"#威胁建模过程\">#</a> 威胁建模过程</h2>\n<ol>\n<li>在项目组中成立一个小组；</li>\n<li>分解系统需求；</li>\n<li>确定系统可能面临哪些威胁；</li>\n<li>画出威胁树，对软件可能受到的威胁进行表达；</li>\n<li>选择应对威胁或者缓和威胁的方法；</li>\n<li>确定最终技术</li>\n</ol>\n<h2 id=\"根据威胁画建模树\"><a class=\"anchor\" href=\"#根据威胁画建模树\">#</a> 根据威胁画建模树</h2>\n<p><img data-src=\"image-12.png\" alt=\"Alt text\" /></p>\n<p><img data-src=\"image-13.png\" alt=\"Alt text\" /></p>\n",
            "tags": [
                "HUST本科学习",
                "HUST",
                "软件安全",
                "期末复习"
            ]
        },
        {
            "id": "https://lessone.top/hello-world/",
            "url": "https://lessone.top/hello-world/",
            "title": "Hello World",
            "date_published": "2024-01-21T11:03:07.459Z",
            "content_html": "<p>Welcome to <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvLw==\">Hexo</span>! This is your very first post. Check <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3Mv\">documentation</span> for more info. If you get any problems when using Hexo, you can find the answer in <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3MvdHJvdWJsZXNob290aW5nLmh0bWw=\">troubleshooting</span> or you can ask me on <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2hleG9qcy9oZXhvL2lzc3Vlcw==\">GitHub</span>.</p>\n<h2 id=\"quick-start\"><a class=\"anchor\" href=\"#quick-start\">#</a> Quick Start</h2>\n<h3 id=\"create-a-new-post\"><a class=\"anchor\" href=\"#create-a-new-post\">#</a> Create a new post</h3>\n<p><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure></p>\n<p>More info: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvd3JpdGluZy5odG1s\">Writing</span></p>\n<h3 id=\"run-server\"><a class=\"anchor\" href=\"#run-server\">#</a> Run server</h3>\n<p><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure></p>\n<p>More info: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvc2VydmVyLmh0bWw=\">Server</span></p>\n<h3 id=\"generate-static-files\"><a class=\"anchor\" href=\"#generate-static-files\">#</a> Generate static files</h3>\n<p><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure></p>\n<p>More info: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3MvZ2VuZXJhdGluZy5odG1s\">Generating</span></p>\n<h3 id=\"deploy-to-remote-sites\"><a class=\"anchor\" href=\"#deploy-to-remote-sites\">#</a> Deploy to remote sites</h3>\n<p><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure></p>\n<p>More info: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvb25lLWNvbW1hbmQtZGVwbG95bWVudC5odG1s\">Deployment</span></p>\n",
            "tags": []
        }
    ]
}